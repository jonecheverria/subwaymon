// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gtfs-realtime.proto

#ifndef PROTOBUF_gtfs_2drealtime_2eproto__INCLUDED
#define PROTOBUF_gtfs_2drealtime_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace transit_realtime {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

class FeedMessage;
class FeedHeader;
class FeedEntity;
class TripUpdate;
class TripUpdate_StopTimeEvent;
class TripUpdate_StopTimeUpdate;
class VehiclePosition;
class Alert;
class TimeRange;
class Position;
class TripDescriptor;
class VehicleDescriptor;
class EntitySelector;
class TranslatedString;
class TranslatedString_Translation;

enum FeedHeader_Incrementality {
  FeedHeader_Incrementality_FULL_DATASET = 0,
  FeedHeader_Incrementality_DIFFERENTIAL = 1
};
bool FeedHeader_Incrementality_IsValid(int value);
const FeedHeader_Incrementality FeedHeader_Incrementality_Incrementality_MIN = FeedHeader_Incrementality_FULL_DATASET;
const FeedHeader_Incrementality FeedHeader_Incrementality_Incrementality_MAX = FeedHeader_Incrementality_DIFFERENTIAL;
const int FeedHeader_Incrementality_Incrementality_ARRAYSIZE = FeedHeader_Incrementality_Incrementality_MAX + 1;

enum TripUpdate_StopTimeUpdate_ScheduleRelationship {
  TripUpdate_StopTimeUpdate_ScheduleRelationship_SCHEDULED = 0,
  TripUpdate_StopTimeUpdate_ScheduleRelationship_SKIPPED = 1,
  TripUpdate_StopTimeUpdate_ScheduleRelationship_NO_DATA = 2
};
bool TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(int value);
const TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MIN = TripUpdate_StopTimeUpdate_ScheduleRelationship_SCHEDULED;
const TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MAX = TripUpdate_StopTimeUpdate_ScheduleRelationship_NO_DATA;
const int TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE = TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MAX + 1;

enum VehiclePosition_VehicleStopStatus {
  VehiclePosition_VehicleStopStatus_INCOMING_AT = 0,
  VehiclePosition_VehicleStopStatus_STOPPED_AT = 1,
  VehiclePosition_VehicleStopStatus_IN_TRANSIT_TO = 2
};
bool VehiclePosition_VehicleStopStatus_IsValid(int value);
const VehiclePosition_VehicleStopStatus VehiclePosition_VehicleStopStatus_VehicleStopStatus_MIN = VehiclePosition_VehicleStopStatus_INCOMING_AT;
const VehiclePosition_VehicleStopStatus VehiclePosition_VehicleStopStatus_VehicleStopStatus_MAX = VehiclePosition_VehicleStopStatus_IN_TRANSIT_TO;
const int VehiclePosition_VehicleStopStatus_VehicleStopStatus_ARRAYSIZE = VehiclePosition_VehicleStopStatus_VehicleStopStatus_MAX + 1;

enum VehiclePosition_CongestionLevel {
  VehiclePosition_CongestionLevel_UNKNOWN_CONGESTION_LEVEL = 0,
  VehiclePosition_CongestionLevel_RUNNING_SMOOTHLY = 1,
  VehiclePosition_CongestionLevel_STOP_AND_GO = 2,
  VehiclePosition_CongestionLevel_CONGESTION = 3,
  VehiclePosition_CongestionLevel_SEVERE_CONGESTION = 4
};
bool VehiclePosition_CongestionLevel_IsValid(int value);
const VehiclePosition_CongestionLevel VehiclePosition_CongestionLevel_CongestionLevel_MIN = VehiclePosition_CongestionLevel_UNKNOWN_CONGESTION_LEVEL;
const VehiclePosition_CongestionLevel VehiclePosition_CongestionLevel_CongestionLevel_MAX = VehiclePosition_CongestionLevel_SEVERE_CONGESTION;
const int VehiclePosition_CongestionLevel_CongestionLevel_ARRAYSIZE = VehiclePosition_CongestionLevel_CongestionLevel_MAX + 1;

enum Alert_Cause {
  Alert_Cause_UNKNOWN_CAUSE = 1,
  Alert_Cause_OTHER_CAUSE = 2,
  Alert_Cause_TECHNICAL_PROBLEM = 3,
  Alert_Cause_STRIKE = 4,
  Alert_Cause_DEMONSTRATION = 5,
  Alert_Cause_ACCIDENT = 6,
  Alert_Cause_HOLIDAY = 7,
  Alert_Cause_WEATHER = 8,
  Alert_Cause_MAINTENANCE = 9,
  Alert_Cause_CONSTRUCTION = 10,
  Alert_Cause_POLICE_ACTIVITY = 11,
  Alert_Cause_MEDICAL_EMERGENCY = 12
};
bool Alert_Cause_IsValid(int value);
const Alert_Cause Alert_Cause_Cause_MIN = Alert_Cause_UNKNOWN_CAUSE;
const Alert_Cause Alert_Cause_Cause_MAX = Alert_Cause_MEDICAL_EMERGENCY;
const int Alert_Cause_Cause_ARRAYSIZE = Alert_Cause_Cause_MAX + 1;

enum Alert_Effect {
  Alert_Effect_NO_SERVICE = 1,
  Alert_Effect_REDUCED_SERVICE = 2,
  Alert_Effect_SIGNIFICANT_DELAYS = 3,
  Alert_Effect_DETOUR = 4,
  Alert_Effect_ADDITIONAL_SERVICE = 5,
  Alert_Effect_MODIFIED_SERVICE = 6,
  Alert_Effect_OTHER_EFFECT = 7,
  Alert_Effect_UNKNOWN_EFFECT = 8,
  Alert_Effect_STOP_MOVED = 9
};
bool Alert_Effect_IsValid(int value);
const Alert_Effect Alert_Effect_Effect_MIN = Alert_Effect_NO_SERVICE;
const Alert_Effect Alert_Effect_Effect_MAX = Alert_Effect_STOP_MOVED;
const int Alert_Effect_Effect_ARRAYSIZE = Alert_Effect_Effect_MAX + 1;

enum TripDescriptor_ScheduleRelationship {
  TripDescriptor_ScheduleRelationship_SCHEDULED = 0,
  TripDescriptor_ScheduleRelationship_ADDED = 1,
  TripDescriptor_ScheduleRelationship_UNSCHEDULED = 2,
  TripDescriptor_ScheduleRelationship_CANCELED = 3,
  TripDescriptor_ScheduleRelationship_REPLACEMENT = 5
};
bool TripDescriptor_ScheduleRelationship_IsValid(int value);
const TripDescriptor_ScheduleRelationship TripDescriptor_ScheduleRelationship_ScheduleRelationship_MIN = TripDescriptor_ScheduleRelationship_SCHEDULED;
const TripDescriptor_ScheduleRelationship TripDescriptor_ScheduleRelationship_ScheduleRelationship_MAX = TripDescriptor_ScheduleRelationship_REPLACEMENT;
const int TripDescriptor_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE = TripDescriptor_ScheduleRelationship_ScheduleRelationship_MAX + 1;

// ===================================================================

class FeedMessage : public ::google::protobuf::MessageLite {
 public:
  FeedMessage();
  virtual ~FeedMessage();

  FeedMessage(const FeedMessage& from);

  inline FeedMessage& operator=(const FeedMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const FeedMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FeedMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FeedMessage* other);

  // implements Message ----------------------------------------------

  FeedMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FeedMessage& from);
  void MergeFrom(const FeedMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .transit_realtime.FeedHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::transit_realtime::FeedHeader& header() const;
  inline ::transit_realtime::FeedHeader* mutable_header();
  inline ::transit_realtime::FeedHeader* release_header();
  inline void set_allocated_header(::transit_realtime::FeedHeader* header);

  // repeated .transit_realtime.FeedEntity entity = 2;
  inline int entity_size() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 2;
  inline const ::transit_realtime::FeedEntity& entity(int index) const;
  inline ::transit_realtime::FeedEntity* mutable_entity(int index);
  inline ::transit_realtime::FeedEntity* add_entity();
  inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::FeedEntity >&
      entity() const;
  inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::FeedEntity >*
      mutable_entity();

  // @@protoc_insertion_point(class_scope:transit_realtime.FeedMessage)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::transit_realtime::FeedHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::FeedEntity > entity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  #endif
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static FeedMessage* default_instance_;
};
// -------------------------------------------------------------------

class FeedHeader : public ::google::protobuf::MessageLite {
 public:
  FeedHeader();
  virtual ~FeedHeader();

  FeedHeader(const FeedHeader& from);

  inline FeedHeader& operator=(const FeedHeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const FeedHeader& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FeedHeader* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FeedHeader* other);

  // implements Message ----------------------------------------------

  FeedHeader* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FeedHeader& from);
  void MergeFrom(const FeedHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef FeedHeader_Incrementality Incrementality;
  static const Incrementality FULL_DATASET = FeedHeader_Incrementality_FULL_DATASET;
  static const Incrementality DIFFERENTIAL = FeedHeader_Incrementality_DIFFERENTIAL;
  static inline bool Incrementality_IsValid(int value) {
    return FeedHeader_Incrementality_IsValid(value);
  }
  static const Incrementality Incrementality_MIN =
    FeedHeader_Incrementality_Incrementality_MIN;
  static const Incrementality Incrementality_MAX =
    FeedHeader_Incrementality_Incrementality_MAX;
  static const int Incrementality_ARRAYSIZE =
    FeedHeader_Incrementality_Incrementality_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required string gtfs_realtime_version = 1;
  inline bool has_gtfs_realtime_version() const;
  inline void clear_gtfs_realtime_version();
  static const int kGtfsRealtimeVersionFieldNumber = 1;
  inline const ::std::string& gtfs_realtime_version() const;
  inline void set_gtfs_realtime_version(const ::std::string& value);
  inline void set_gtfs_realtime_version(const char* value);
  inline void set_gtfs_realtime_version(const char* value, size_t size);
  inline ::std::string* mutable_gtfs_realtime_version();
  inline ::std::string* release_gtfs_realtime_version();
  inline void set_allocated_gtfs_realtime_version(::std::string* gtfs_realtime_version);

  // optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];
  inline bool has_incrementality() const;
  inline void clear_incrementality();
  static const int kIncrementalityFieldNumber = 2;
  inline ::transit_realtime::FeedHeader_Incrementality incrementality() const;
  inline void set_incrementality(::transit_realtime::FeedHeader_Incrementality value);

  // optional uint64 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(FeedHeader)
  // @@protoc_insertion_point(class_scope:transit_realtime.FeedHeader)
 private:
  inline void set_has_gtfs_realtime_version();
  inline void clear_has_gtfs_realtime_version();
  inline void set_has_incrementality();
  inline void clear_has_incrementality();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::std::string* gtfs_realtime_version_;
  ::google::protobuf::uint64 timestamp_;
  int incrementality_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  #endif
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static FeedHeader* default_instance_;
};
// -------------------------------------------------------------------

class FeedEntity : public ::google::protobuf::MessageLite {
 public:
  FeedEntity();
  virtual ~FeedEntity();

  FeedEntity(const FeedEntity& from);

  inline FeedEntity& operator=(const FeedEntity& from) {
    CopyFrom(from);
    return *this;
  }

  static const FeedEntity& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FeedEntity* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FeedEntity* other);

  // implements Message ----------------------------------------------

  FeedEntity* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FeedEntity& from);
  void MergeFrom(const FeedEntity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional bool is_deleted = 2 [default = false];
  inline bool has_is_deleted() const;
  inline void clear_is_deleted();
  static const int kIsDeletedFieldNumber = 2;
  inline bool is_deleted() const;
  inline void set_is_deleted(bool value);

  // optional .transit_realtime.TripUpdate trip_update = 3;
  inline bool has_trip_update() const;
  inline void clear_trip_update();
  static const int kTripUpdateFieldNumber = 3;
  inline const ::transit_realtime::TripUpdate& trip_update() const;
  inline ::transit_realtime::TripUpdate* mutable_trip_update();
  inline ::transit_realtime::TripUpdate* release_trip_update();
  inline void set_allocated_trip_update(::transit_realtime::TripUpdate* trip_update);

  // optional .transit_realtime.VehiclePosition vehicle = 4;
  inline bool has_vehicle() const;
  inline void clear_vehicle();
  static const int kVehicleFieldNumber = 4;
  inline const ::transit_realtime::VehiclePosition& vehicle() const;
  inline ::transit_realtime::VehiclePosition* mutable_vehicle();
  inline ::transit_realtime::VehiclePosition* release_vehicle();
  inline void set_allocated_vehicle(::transit_realtime::VehiclePosition* vehicle);

  // optional .transit_realtime.Alert alert = 5;
  inline bool has_alert() const;
  inline void clear_alert();
  static const int kAlertFieldNumber = 5;
  inline const ::transit_realtime::Alert& alert() const;
  inline ::transit_realtime::Alert* mutable_alert();
  inline ::transit_realtime::Alert* release_alert();
  inline void set_allocated_alert(::transit_realtime::Alert* alert);

  // @@protoc_insertion_point(class_scope:transit_realtime.FeedEntity)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_is_deleted();
  inline void clear_has_is_deleted();
  inline void set_has_trip_update();
  inline void clear_has_trip_update();
  inline void set_has_vehicle();
  inline void clear_has_vehicle();
  inline void set_has_alert();
  inline void clear_has_alert();

  ::std::string* id_;
  ::transit_realtime::TripUpdate* trip_update_;
  ::transit_realtime::VehiclePosition* vehicle_;
  ::transit_realtime::Alert* alert_;
  bool is_deleted_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  #endif
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static FeedEntity* default_instance_;
};
// -------------------------------------------------------------------

class TripUpdate_StopTimeEvent : public ::google::protobuf::MessageLite {
 public:
  TripUpdate_StopTimeEvent();
  virtual ~TripUpdate_StopTimeEvent();

  TripUpdate_StopTimeEvent(const TripUpdate_StopTimeEvent& from);

  inline TripUpdate_StopTimeEvent& operator=(const TripUpdate_StopTimeEvent& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripUpdate_StopTimeEvent& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripUpdate_StopTimeEvent* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripUpdate_StopTimeEvent* other);

  // implements Message ----------------------------------------------

  TripUpdate_StopTimeEvent* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripUpdate_StopTimeEvent& from);
  void MergeFrom(const TripUpdate_StopTimeEvent& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 delay = 1;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 1;
  inline ::google::protobuf::int32 delay() const;
  inline void set_delay(::google::protobuf::int32 value);

  // optional int64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // optional int32 uncertainty = 3;
  inline bool has_uncertainty() const;
  inline void clear_uncertainty();
  static const int kUncertaintyFieldNumber = 3;
  inline ::google::protobuf::int32 uncertainty() const;
  inline void set_uncertainty(::google::protobuf::int32 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(TripUpdate_StopTimeEvent)
  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.StopTimeEvent)
 private:
  inline void set_has_delay();
  inline void clear_has_delay();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_uncertainty();
  inline void clear_has_uncertainty();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 delay_;
  ::google::protobuf::int32 uncertainty_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  #endif
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static TripUpdate_StopTimeEvent* default_instance_;
};
// -------------------------------------------------------------------

class TripUpdate_StopTimeUpdate : public ::google::protobuf::MessageLite {
 public:
  TripUpdate_StopTimeUpdate();
  virtual ~TripUpdate_StopTimeUpdate();

  TripUpdate_StopTimeUpdate(const TripUpdate_StopTimeUpdate& from);

  inline TripUpdate_StopTimeUpdate& operator=(const TripUpdate_StopTimeUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripUpdate_StopTimeUpdate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripUpdate_StopTimeUpdate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripUpdate_StopTimeUpdate* other);

  // implements Message ----------------------------------------------

  TripUpdate_StopTimeUpdate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripUpdate_StopTimeUpdate& from);
  void MergeFrom(const TripUpdate_StopTimeUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TripUpdate_StopTimeUpdate_ScheduleRelationship ScheduleRelationship;
  static const ScheduleRelationship SCHEDULED = TripUpdate_StopTimeUpdate_ScheduleRelationship_SCHEDULED;
  static const ScheduleRelationship SKIPPED = TripUpdate_StopTimeUpdate_ScheduleRelationship_SKIPPED;
  static const ScheduleRelationship NO_DATA = TripUpdate_StopTimeUpdate_ScheduleRelationship_NO_DATA;
  static inline bool ScheduleRelationship_IsValid(int value) {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(value);
  }
  static const ScheduleRelationship ScheduleRelationship_MIN =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MIN;
  static const ScheduleRelationship ScheduleRelationship_MAX =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MAX;
  static const int ScheduleRelationship_ARRAYSIZE =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional uint32 stop_sequence = 1;
  inline bool has_stop_sequence() const;
  inline void clear_stop_sequence();
  static const int kStopSequenceFieldNumber = 1;
  inline ::google::protobuf::uint32 stop_sequence() const;
  inline void set_stop_sequence(::google::protobuf::uint32 value);

  // optional string stop_id = 4;
  inline bool has_stop_id() const;
  inline void clear_stop_id();
  static const int kStopIdFieldNumber = 4;
  inline const ::std::string& stop_id() const;
  inline void set_stop_id(const ::std::string& value);
  inline void set_stop_id(const char* value);
  inline void set_stop_id(const char* value, size_t size);
  inline ::std::string* mutable_stop_id();
  inline ::std::string* release_stop_id();
  inline void set_allocated_stop_id(::std::string* stop_id);

  // optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;
  inline bool has_arrival() const;
  inline void clear_arrival();
  static const int kArrivalFieldNumber = 2;
  inline const ::transit_realtime::TripUpdate_StopTimeEvent& arrival() const;
  inline ::transit_realtime::TripUpdate_StopTimeEvent* mutable_arrival();
  inline ::transit_realtime::TripUpdate_StopTimeEvent* release_arrival();
  inline void set_allocated_arrival(::transit_realtime::TripUpdate_StopTimeEvent* arrival);

  // optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;
  inline bool has_departure() const;
  inline void clear_departure();
  static const int kDepartureFieldNumber = 3;
  inline const ::transit_realtime::TripUpdate_StopTimeEvent& departure() const;
  inline ::transit_realtime::TripUpdate_StopTimeEvent* mutable_departure();
  inline ::transit_realtime::TripUpdate_StopTimeEvent* release_departure();
  inline void set_allocated_departure(::transit_realtime::TripUpdate_StopTimeEvent* departure);

  // optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];
  inline bool has_schedule_relationship() const;
  inline void clear_schedule_relationship();
  static const int kScheduleRelationshipFieldNumber = 5;
  inline ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship schedule_relationship() const;
  inline void set_schedule_relationship(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(TripUpdate_StopTimeUpdate)
  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.StopTimeUpdate)
 private:
  inline void set_has_stop_sequence();
  inline void clear_has_stop_sequence();
  inline void set_has_stop_id();
  inline void clear_has_stop_id();
  inline void set_has_arrival();
  inline void clear_has_arrival();
  inline void set_has_departure();
  inline void clear_has_departure();
  inline void set_has_schedule_relationship();
  inline void clear_has_schedule_relationship();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::std::string* stop_id_;
  ::transit_realtime::TripUpdate_StopTimeEvent* arrival_;
  ::google::protobuf::uint32 stop_sequence_;
  int schedule_relationship_;
  ::transit_realtime::TripUpdate_StopTimeEvent* departure_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  #endif
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static TripUpdate_StopTimeUpdate* default_instance_;
};
// -------------------------------------------------------------------

class TripUpdate : public ::google::protobuf::MessageLite {
 public:
  TripUpdate();
  virtual ~TripUpdate();

  TripUpdate(const TripUpdate& from);

  inline TripUpdate& operator=(const TripUpdate& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripUpdate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripUpdate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripUpdate* other);

  // implements Message ----------------------------------------------

  TripUpdate* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripUpdate& from);
  void MergeFrom(const TripUpdate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TripUpdate_StopTimeEvent StopTimeEvent;
  typedef TripUpdate_StopTimeUpdate StopTimeUpdate;

  // accessors -------------------------------------------------------

  // required .transit_realtime.TripDescriptor trip = 1;
  inline bool has_trip() const;
  inline void clear_trip();
  static const int kTripFieldNumber = 1;
  inline const ::transit_realtime::TripDescriptor& trip() const;
  inline ::transit_realtime::TripDescriptor* mutable_trip();
  inline ::transit_realtime::TripDescriptor* release_trip();
  inline void set_allocated_trip(::transit_realtime::TripDescriptor* trip);

  // optional .transit_realtime.VehicleDescriptor vehicle = 3;
  inline bool has_vehicle() const;
  inline void clear_vehicle();
  static const int kVehicleFieldNumber = 3;
  inline const ::transit_realtime::VehicleDescriptor& vehicle() const;
  inline ::transit_realtime::VehicleDescriptor* mutable_vehicle();
  inline ::transit_realtime::VehicleDescriptor* release_vehicle();
  inline void set_allocated_vehicle(::transit_realtime::VehicleDescriptor* vehicle);

  // repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;
  inline int stop_time_update_size() const;
  inline void clear_stop_time_update();
  static const int kStopTimeUpdateFieldNumber = 2;
  inline const ::transit_realtime::TripUpdate_StopTimeUpdate& stop_time_update(int index) const;
  inline ::transit_realtime::TripUpdate_StopTimeUpdate* mutable_stop_time_update(int index);
  inline ::transit_realtime::TripUpdate_StopTimeUpdate* add_stop_time_update();
  inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >&
      stop_time_update() const;
  inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >*
      mutable_stop_time_update();

  // optional uint64 timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(TripUpdate)
  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate)
 private:
  inline void set_has_trip();
  inline void clear_has_trip();
  inline void set_has_vehicle();
  inline void clear_has_vehicle();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::transit_realtime::TripDescriptor* trip_;
  ::transit_realtime::VehicleDescriptor* vehicle_;
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate > stop_time_update_;
  ::google::protobuf::uint64 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  #endif
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static TripUpdate* default_instance_;
};
// -------------------------------------------------------------------

class VehiclePosition : public ::google::protobuf::MessageLite {
 public:
  VehiclePosition();
  virtual ~VehiclePosition();

  VehiclePosition(const VehiclePosition& from);

  inline VehiclePosition& operator=(const VehiclePosition& from) {
    CopyFrom(from);
    return *this;
  }

  static const VehiclePosition& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VehiclePosition* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VehiclePosition* other);

  // implements Message ----------------------------------------------

  VehiclePosition* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VehiclePosition& from);
  void MergeFrom(const VehiclePosition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef VehiclePosition_VehicleStopStatus VehicleStopStatus;
  static const VehicleStopStatus INCOMING_AT = VehiclePosition_VehicleStopStatus_INCOMING_AT;
  static const VehicleStopStatus STOPPED_AT = VehiclePosition_VehicleStopStatus_STOPPED_AT;
  static const VehicleStopStatus IN_TRANSIT_TO = VehiclePosition_VehicleStopStatus_IN_TRANSIT_TO;
  static inline bool VehicleStopStatus_IsValid(int value) {
    return VehiclePosition_VehicleStopStatus_IsValid(value);
  }
  static const VehicleStopStatus VehicleStopStatus_MIN =
    VehiclePosition_VehicleStopStatus_VehicleStopStatus_MIN;
  static const VehicleStopStatus VehicleStopStatus_MAX =
    VehiclePosition_VehicleStopStatus_VehicleStopStatus_MAX;
  static const int VehicleStopStatus_ARRAYSIZE =
    VehiclePosition_VehicleStopStatus_VehicleStopStatus_ARRAYSIZE;

  typedef VehiclePosition_CongestionLevel CongestionLevel;
  static const CongestionLevel UNKNOWN_CONGESTION_LEVEL = VehiclePosition_CongestionLevel_UNKNOWN_CONGESTION_LEVEL;
  static const CongestionLevel RUNNING_SMOOTHLY = VehiclePosition_CongestionLevel_RUNNING_SMOOTHLY;
  static const CongestionLevel STOP_AND_GO = VehiclePosition_CongestionLevel_STOP_AND_GO;
  static const CongestionLevel CONGESTION = VehiclePosition_CongestionLevel_CONGESTION;
  static const CongestionLevel SEVERE_CONGESTION = VehiclePosition_CongestionLevel_SEVERE_CONGESTION;
  static inline bool CongestionLevel_IsValid(int value) {
    return VehiclePosition_CongestionLevel_IsValid(value);
  }
  static const CongestionLevel CongestionLevel_MIN =
    VehiclePosition_CongestionLevel_CongestionLevel_MIN;
  static const CongestionLevel CongestionLevel_MAX =
    VehiclePosition_CongestionLevel_CongestionLevel_MAX;
  static const int CongestionLevel_ARRAYSIZE =
    VehiclePosition_CongestionLevel_CongestionLevel_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .transit_realtime.TripDescriptor trip = 1;
  inline bool has_trip() const;
  inline void clear_trip();
  static const int kTripFieldNumber = 1;
  inline const ::transit_realtime::TripDescriptor& trip() const;
  inline ::transit_realtime::TripDescriptor* mutable_trip();
  inline ::transit_realtime::TripDescriptor* release_trip();
  inline void set_allocated_trip(::transit_realtime::TripDescriptor* trip);

  // optional .transit_realtime.VehicleDescriptor vehicle = 8;
  inline bool has_vehicle() const;
  inline void clear_vehicle();
  static const int kVehicleFieldNumber = 8;
  inline const ::transit_realtime::VehicleDescriptor& vehicle() const;
  inline ::transit_realtime::VehicleDescriptor* mutable_vehicle();
  inline ::transit_realtime::VehicleDescriptor* release_vehicle();
  inline void set_allocated_vehicle(::transit_realtime::VehicleDescriptor* vehicle);

  // optional .transit_realtime.Position position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline const ::transit_realtime::Position& position() const;
  inline ::transit_realtime::Position* mutable_position();
  inline ::transit_realtime::Position* release_position();
  inline void set_allocated_position(::transit_realtime::Position* position);

  // optional uint32 current_stop_sequence = 3;
  inline bool has_current_stop_sequence() const;
  inline void clear_current_stop_sequence();
  static const int kCurrentStopSequenceFieldNumber = 3;
  inline ::google::protobuf::uint32 current_stop_sequence() const;
  inline void set_current_stop_sequence(::google::protobuf::uint32 value);

  // optional string stop_id = 7;
  inline bool has_stop_id() const;
  inline void clear_stop_id();
  static const int kStopIdFieldNumber = 7;
  inline const ::std::string& stop_id() const;
  inline void set_stop_id(const ::std::string& value);
  inline void set_stop_id(const char* value);
  inline void set_stop_id(const char* value, size_t size);
  inline ::std::string* mutable_stop_id();
  inline ::std::string* release_stop_id();
  inline void set_allocated_stop_id(::std::string* stop_id);

  // optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];
  inline bool has_current_status() const;
  inline void clear_current_status();
  static const int kCurrentStatusFieldNumber = 4;
  inline ::transit_realtime::VehiclePosition_VehicleStopStatus current_status() const;
  inline void set_current_status(::transit_realtime::VehiclePosition_VehicleStopStatus value);

  // optional uint64 timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;
  inline bool has_congestion_level() const;
  inline void clear_congestion_level();
  static const int kCongestionLevelFieldNumber = 6;
  inline ::transit_realtime::VehiclePosition_CongestionLevel congestion_level() const;
  inline void set_congestion_level(::transit_realtime::VehiclePosition_CongestionLevel value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(VehiclePosition)
  // @@protoc_insertion_point(class_scope:transit_realtime.VehiclePosition)
 private:
  inline void set_has_trip();
  inline void clear_has_trip();
  inline void set_has_vehicle();
  inline void clear_has_vehicle();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_current_stop_sequence();
  inline void clear_has_current_stop_sequence();
  inline void set_has_stop_id();
  inline void clear_has_stop_id();
  inline void set_has_current_status();
  inline void clear_has_current_status();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_congestion_level();
  inline void clear_has_congestion_level();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::transit_realtime::TripDescriptor* trip_;
  ::transit_realtime::VehicleDescriptor* vehicle_;
  ::transit_realtime::Position* position_;
  ::std::string* stop_id_;
  ::google::protobuf::uint32 current_stop_sequence_;
  int current_status_;
  ::google::protobuf::uint64 timestamp_;
  int congestion_level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  #endif
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static VehiclePosition* default_instance_;
};
// -------------------------------------------------------------------

class Alert : public ::google::protobuf::MessageLite {
 public:
  Alert();
  virtual ~Alert();

  Alert(const Alert& from);

  inline Alert& operator=(const Alert& from) {
    CopyFrom(from);
    return *this;
  }

  static const Alert& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Alert* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Alert* other);

  // implements Message ----------------------------------------------

  Alert* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Alert& from);
  void MergeFrom(const Alert& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef Alert_Cause Cause;
  static const Cause UNKNOWN_CAUSE = Alert_Cause_UNKNOWN_CAUSE;
  static const Cause OTHER_CAUSE = Alert_Cause_OTHER_CAUSE;
  static const Cause TECHNICAL_PROBLEM = Alert_Cause_TECHNICAL_PROBLEM;
  static const Cause STRIKE = Alert_Cause_STRIKE;
  static const Cause DEMONSTRATION = Alert_Cause_DEMONSTRATION;
  static const Cause ACCIDENT = Alert_Cause_ACCIDENT;
  static const Cause HOLIDAY = Alert_Cause_HOLIDAY;
  static const Cause WEATHER = Alert_Cause_WEATHER;
  static const Cause MAINTENANCE = Alert_Cause_MAINTENANCE;
  static const Cause CONSTRUCTION = Alert_Cause_CONSTRUCTION;
  static const Cause POLICE_ACTIVITY = Alert_Cause_POLICE_ACTIVITY;
  static const Cause MEDICAL_EMERGENCY = Alert_Cause_MEDICAL_EMERGENCY;
  static inline bool Cause_IsValid(int value) {
    return Alert_Cause_IsValid(value);
  }
  static const Cause Cause_MIN =
    Alert_Cause_Cause_MIN;
  static const Cause Cause_MAX =
    Alert_Cause_Cause_MAX;
  static const int Cause_ARRAYSIZE =
    Alert_Cause_Cause_ARRAYSIZE;

  typedef Alert_Effect Effect;
  static const Effect NO_SERVICE = Alert_Effect_NO_SERVICE;
  static const Effect REDUCED_SERVICE = Alert_Effect_REDUCED_SERVICE;
  static const Effect SIGNIFICANT_DELAYS = Alert_Effect_SIGNIFICANT_DELAYS;
  static const Effect DETOUR = Alert_Effect_DETOUR;
  static const Effect ADDITIONAL_SERVICE = Alert_Effect_ADDITIONAL_SERVICE;
  static const Effect MODIFIED_SERVICE = Alert_Effect_MODIFIED_SERVICE;
  static const Effect OTHER_EFFECT = Alert_Effect_OTHER_EFFECT;
  static const Effect UNKNOWN_EFFECT = Alert_Effect_UNKNOWN_EFFECT;
  static const Effect STOP_MOVED = Alert_Effect_STOP_MOVED;
  static inline bool Effect_IsValid(int value) {
    return Alert_Effect_IsValid(value);
  }
  static const Effect Effect_MIN =
    Alert_Effect_Effect_MIN;
  static const Effect Effect_MAX =
    Alert_Effect_Effect_MAX;
  static const int Effect_ARRAYSIZE =
    Alert_Effect_Effect_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated .transit_realtime.TimeRange active_period = 1;
  inline int active_period_size() const;
  inline void clear_active_period();
  static const int kActivePeriodFieldNumber = 1;
  inline const ::transit_realtime::TimeRange& active_period(int index) const;
  inline ::transit_realtime::TimeRange* mutable_active_period(int index);
  inline ::transit_realtime::TimeRange* add_active_period();
  inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange >&
      active_period() const;
  inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange >*
      mutable_active_period();

  // repeated .transit_realtime.EntitySelector informed_entity = 5;
  inline int informed_entity_size() const;
  inline void clear_informed_entity();
  static const int kInformedEntityFieldNumber = 5;
  inline const ::transit_realtime::EntitySelector& informed_entity(int index) const;
  inline ::transit_realtime::EntitySelector* mutable_informed_entity(int index);
  inline ::transit_realtime::EntitySelector* add_informed_entity();
  inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::EntitySelector >&
      informed_entity() const;
  inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::EntitySelector >*
      mutable_informed_entity();

  // optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];
  inline bool has_cause() const;
  inline void clear_cause();
  static const int kCauseFieldNumber = 6;
  inline ::transit_realtime::Alert_Cause cause() const;
  inline void set_cause(::transit_realtime::Alert_Cause value);

  // optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];
  inline bool has_effect() const;
  inline void clear_effect();
  static const int kEffectFieldNumber = 7;
  inline ::transit_realtime::Alert_Effect effect() const;
  inline void set_effect(::transit_realtime::Alert_Effect value);

  // optional .transit_realtime.TranslatedString url = 8;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 8;
  inline const ::transit_realtime::TranslatedString& url() const;
  inline ::transit_realtime::TranslatedString* mutable_url();
  inline ::transit_realtime::TranslatedString* release_url();
  inline void set_allocated_url(::transit_realtime::TranslatedString* url);

  // optional .transit_realtime.TranslatedString header_text = 10;
  inline bool has_header_text() const;
  inline void clear_header_text();
  static const int kHeaderTextFieldNumber = 10;
  inline const ::transit_realtime::TranslatedString& header_text() const;
  inline ::transit_realtime::TranslatedString* mutable_header_text();
  inline ::transit_realtime::TranslatedString* release_header_text();
  inline void set_allocated_header_text(::transit_realtime::TranslatedString* header_text);

  // optional .transit_realtime.TranslatedString description_text = 11;
  inline bool has_description_text() const;
  inline void clear_description_text();
  static const int kDescriptionTextFieldNumber = 11;
  inline const ::transit_realtime::TranslatedString& description_text() const;
  inline ::transit_realtime::TranslatedString* mutable_description_text();
  inline ::transit_realtime::TranslatedString* release_description_text();
  inline void set_allocated_description_text(::transit_realtime::TranslatedString* description_text);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Alert)
  // @@protoc_insertion_point(class_scope:transit_realtime.Alert)
 private:
  inline void set_has_cause();
  inline void clear_has_cause();
  inline void set_has_effect();
  inline void clear_has_effect();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_header_text();
  inline void clear_has_header_text();
  inline void set_has_description_text();
  inline void clear_has_description_text();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange > active_period_;
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::EntitySelector > informed_entity_;
  int cause_;
  int effect_;
  ::transit_realtime::TranslatedString* url_;
  ::transit_realtime::TranslatedString* header_text_;
  ::transit_realtime::TranslatedString* description_text_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  #endif
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static Alert* default_instance_;
};
// -------------------------------------------------------------------

class TimeRange : public ::google::protobuf::MessageLite {
 public:
  TimeRange();
  virtual ~TimeRange();

  TimeRange(const TimeRange& from);

  inline TimeRange& operator=(const TimeRange& from) {
    CopyFrom(from);
    return *this;
  }

  static const TimeRange& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TimeRange* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TimeRange* other);

  // implements Message ----------------------------------------------

  TimeRange* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TimeRange& from);
  void MergeFrom(const TimeRange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline ::google::protobuf::uint64 start() const;
  inline void set_start(::google::protobuf::uint64 value);

  // optional uint64 end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline ::google::protobuf::uint64 end() const;
  inline void set_end(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:transit_realtime.TimeRange)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_end();
  inline void clear_has_end();

  ::google::protobuf::uint64 start_;
  ::google::protobuf::uint64 end_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  #endif
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static TimeRange* default_instance_;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::MessageLite {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }

  static const Position& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Position* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Position* other);

  // implements Message ----------------------------------------------

  Position* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float latitude = 1;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  inline float latitude() const;
  inline void set_latitude(float value);

  // required float longitude = 2;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  inline float longitude() const;
  inline void set_longitude(float value);

  // optional float bearing = 3;
  inline bool has_bearing() const;
  inline void clear_bearing();
  static const int kBearingFieldNumber = 3;
  inline float bearing() const;
  inline void set_bearing(float value);

  // optional double odometer = 4;
  inline bool has_odometer() const;
  inline void clear_odometer();
  static const int kOdometerFieldNumber = 4;
  inline double odometer() const;
  inline void set_odometer(double value);

  // optional float speed = 5;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 5;
  inline float speed() const;
  inline void set_speed(float value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Position)
  // @@protoc_insertion_point(class_scope:transit_realtime.Position)
 private:
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_bearing();
  inline void clear_has_bearing();
  inline void set_has_odometer();
  inline void clear_has_odometer();
  inline void set_has_speed();
  inline void clear_has_speed();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  float latitude_;
  float longitude_;
  double odometer_;
  float bearing_;
  float speed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  #endif
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class TripDescriptor : public ::google::protobuf::MessageLite {
 public:
  TripDescriptor();
  virtual ~TripDescriptor();

  TripDescriptor(const TripDescriptor& from);

  inline TripDescriptor& operator=(const TripDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  static const TripDescriptor& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TripDescriptor* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TripDescriptor* other);

  // implements Message ----------------------------------------------

  TripDescriptor* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TripDescriptor& from);
  void MergeFrom(const TripDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TripDescriptor_ScheduleRelationship ScheduleRelationship;
  static const ScheduleRelationship SCHEDULED = TripDescriptor_ScheduleRelationship_SCHEDULED;
  static const ScheduleRelationship ADDED = TripDescriptor_ScheduleRelationship_ADDED;
  static const ScheduleRelationship UNSCHEDULED = TripDescriptor_ScheduleRelationship_UNSCHEDULED;
  static const ScheduleRelationship CANCELED = TripDescriptor_ScheduleRelationship_CANCELED;
  static const ScheduleRelationship REPLACEMENT = TripDescriptor_ScheduleRelationship_REPLACEMENT;
  static inline bool ScheduleRelationship_IsValid(int value) {
    return TripDescriptor_ScheduleRelationship_IsValid(value);
  }
  static const ScheduleRelationship ScheduleRelationship_MIN =
    TripDescriptor_ScheduleRelationship_ScheduleRelationship_MIN;
  static const ScheduleRelationship ScheduleRelationship_MAX =
    TripDescriptor_ScheduleRelationship_ScheduleRelationship_MAX;
  static const int ScheduleRelationship_ARRAYSIZE =
    TripDescriptor_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string trip_id = 1;
  inline bool has_trip_id() const;
  inline void clear_trip_id();
  static const int kTripIdFieldNumber = 1;
  inline const ::std::string& trip_id() const;
  inline void set_trip_id(const ::std::string& value);
  inline void set_trip_id(const char* value);
  inline void set_trip_id(const char* value, size_t size);
  inline ::std::string* mutable_trip_id();
  inline ::std::string* release_trip_id();
  inline void set_allocated_trip_id(::std::string* trip_id);

  // optional string route_id = 5;
  inline bool has_route_id() const;
  inline void clear_route_id();
  static const int kRouteIdFieldNumber = 5;
  inline const ::std::string& route_id() const;
  inline void set_route_id(const ::std::string& value);
  inline void set_route_id(const char* value);
  inline void set_route_id(const char* value, size_t size);
  inline ::std::string* mutable_route_id();
  inline ::std::string* release_route_id();
  inline void set_allocated_route_id(::std::string* route_id);

  // optional string start_time = 2;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  inline const ::std::string& start_time() const;
  inline void set_start_time(const ::std::string& value);
  inline void set_start_time(const char* value);
  inline void set_start_time(const char* value, size_t size);
  inline ::std::string* mutable_start_time();
  inline ::std::string* release_start_time();
  inline void set_allocated_start_time(::std::string* start_time);

  // optional string start_date = 3;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 3;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const char* value, size_t size);
  inline ::std::string* mutable_start_date();
  inline ::std::string* release_start_date();
  inline void set_allocated_start_date(::std::string* start_date);

  // optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
  inline bool has_schedule_relationship() const;
  inline void clear_schedule_relationship();
  static const int kScheduleRelationshipFieldNumber = 4;
  inline ::transit_realtime::TripDescriptor_ScheduleRelationship schedule_relationship() const;
  inline void set_schedule_relationship(::transit_realtime::TripDescriptor_ScheduleRelationship value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(TripDescriptor)
  // @@protoc_insertion_point(class_scope:transit_realtime.TripDescriptor)
 private:
  inline void set_has_trip_id();
  inline void clear_has_trip_id();
  inline void set_has_route_id();
  inline void clear_has_route_id();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_start_date();
  inline void clear_has_start_date();
  inline void set_has_schedule_relationship();
  inline void clear_has_schedule_relationship();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::std::string* trip_id_;
  ::std::string* route_id_;
  ::std::string* start_time_;
  ::std::string* start_date_;
  int schedule_relationship_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  #endif
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static TripDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class VehicleDescriptor : public ::google::protobuf::MessageLite {
 public:
  VehicleDescriptor();
  virtual ~VehicleDescriptor();

  VehicleDescriptor(const VehicleDescriptor& from);

  inline VehicleDescriptor& operator=(const VehicleDescriptor& from) {
    CopyFrom(from);
    return *this;
  }

  static const VehicleDescriptor& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VehicleDescriptor* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VehicleDescriptor* other);

  // implements Message ----------------------------------------------

  VehicleDescriptor* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VehicleDescriptor& from);
  void MergeFrom(const VehicleDescriptor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string label = 2;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 2;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional string license_plate = 3;
  inline bool has_license_plate() const;
  inline void clear_license_plate();
  static const int kLicensePlateFieldNumber = 3;
  inline const ::std::string& license_plate() const;
  inline void set_license_plate(const ::std::string& value);
  inline void set_license_plate(const char* value);
  inline void set_license_plate(const char* value, size_t size);
  inline ::std::string* mutable_license_plate();
  inline ::std::string* release_license_plate();
  inline void set_allocated_license_plate(::std::string* license_plate);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(VehicleDescriptor)
  // @@protoc_insertion_point(class_scope:transit_realtime.VehicleDescriptor)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_license_plate();
  inline void clear_has_license_plate();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::std::string* id_;
  ::std::string* label_;
  ::std::string* license_plate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  #endif
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static VehicleDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class EntitySelector : public ::google::protobuf::MessageLite {
 public:
  EntitySelector();
  virtual ~EntitySelector();

  EntitySelector(const EntitySelector& from);

  inline EntitySelector& operator=(const EntitySelector& from) {
    CopyFrom(from);
    return *this;
  }

  static const EntitySelector& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EntitySelector* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EntitySelector* other);

  // implements Message ----------------------------------------------

  EntitySelector* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EntitySelector& from);
  void MergeFrom(const EntitySelector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string agency_id = 1;
  inline bool has_agency_id() const;
  inline void clear_agency_id();
  static const int kAgencyIdFieldNumber = 1;
  inline const ::std::string& agency_id() const;
  inline void set_agency_id(const ::std::string& value);
  inline void set_agency_id(const char* value);
  inline void set_agency_id(const char* value, size_t size);
  inline ::std::string* mutable_agency_id();
  inline ::std::string* release_agency_id();
  inline void set_allocated_agency_id(::std::string* agency_id);

  // optional string route_id = 2;
  inline bool has_route_id() const;
  inline void clear_route_id();
  static const int kRouteIdFieldNumber = 2;
  inline const ::std::string& route_id() const;
  inline void set_route_id(const ::std::string& value);
  inline void set_route_id(const char* value);
  inline void set_route_id(const char* value, size_t size);
  inline ::std::string* mutable_route_id();
  inline ::std::string* release_route_id();
  inline void set_allocated_route_id(::std::string* route_id);

  // optional int32 route_type = 3;
  inline bool has_route_type() const;
  inline void clear_route_type();
  static const int kRouteTypeFieldNumber = 3;
  inline ::google::protobuf::int32 route_type() const;
  inline void set_route_type(::google::protobuf::int32 value);

  // optional .transit_realtime.TripDescriptor trip = 4;
  inline bool has_trip() const;
  inline void clear_trip();
  static const int kTripFieldNumber = 4;
  inline const ::transit_realtime::TripDescriptor& trip() const;
  inline ::transit_realtime::TripDescriptor* mutable_trip();
  inline ::transit_realtime::TripDescriptor* release_trip();
  inline void set_allocated_trip(::transit_realtime::TripDescriptor* trip);

  // optional string stop_id = 5;
  inline bool has_stop_id() const;
  inline void clear_stop_id();
  static const int kStopIdFieldNumber = 5;
  inline const ::std::string& stop_id() const;
  inline void set_stop_id(const ::std::string& value);
  inline void set_stop_id(const char* value);
  inline void set_stop_id(const char* value, size_t size);
  inline ::std::string* mutable_stop_id();
  inline ::std::string* release_stop_id();
  inline void set_allocated_stop_id(::std::string* stop_id);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(EntitySelector)
  // @@protoc_insertion_point(class_scope:transit_realtime.EntitySelector)
 private:
  inline void set_has_agency_id();
  inline void clear_has_agency_id();
  inline void set_has_route_id();
  inline void clear_has_route_id();
  inline void set_has_route_type();
  inline void clear_has_route_type();
  inline void set_has_trip();
  inline void clear_has_trip();
  inline void set_has_stop_id();
  inline void clear_has_stop_id();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::std::string* agency_id_;
  ::std::string* route_id_;
  ::transit_realtime::TripDescriptor* trip_;
  ::std::string* stop_id_;
  ::google::protobuf::int32 route_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  #endif
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static EntitySelector* default_instance_;
};
// -------------------------------------------------------------------

class TranslatedString_Translation : public ::google::protobuf::MessageLite {
 public:
  TranslatedString_Translation();
  virtual ~TranslatedString_Translation();

  TranslatedString_Translation(const TranslatedString_Translation& from);

  inline TranslatedString_Translation& operator=(const TranslatedString_Translation& from) {
    CopyFrom(from);
    return *this;
  }

  static const TranslatedString_Translation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TranslatedString_Translation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TranslatedString_Translation* other);

  // implements Message ----------------------------------------------

  TranslatedString_Translation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TranslatedString_Translation& from);
  void MergeFrom(const TranslatedString_Translation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional string language = 2;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 2;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  inline ::std::string* release_language();
  inline void set_allocated_language(::std::string* language);

  // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedString.Translation)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_language();
  inline void clear_has_language();

  ::std::string* text_;
  ::std::string* language_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  #endif
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static TranslatedString_Translation* default_instance_;
};
// -------------------------------------------------------------------

class TranslatedString : public ::google::protobuf::MessageLite {
 public:
  TranslatedString();
  virtual ~TranslatedString();

  TranslatedString(const TranslatedString& from);

  inline TranslatedString& operator=(const TranslatedString& from) {
    CopyFrom(from);
    return *this;
  }

  static const TranslatedString& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TranslatedString* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TranslatedString* other);

  // implements Message ----------------------------------------------

  TranslatedString* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TranslatedString& from);
  void MergeFrom(const TranslatedString& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TranslatedString_Translation Translation;

  // accessors -------------------------------------------------------

  // repeated .transit_realtime.TranslatedString.Translation translation = 1;
  inline int translation_size() const;
  inline void clear_translation();
  static const int kTranslationFieldNumber = 1;
  inline const ::transit_realtime::TranslatedString_Translation& translation(int index) const;
  inline ::transit_realtime::TranslatedString_Translation* mutable_translation(int index);
  inline ::transit_realtime::TranslatedString_Translation* add_translation();
  inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >&
      translation() const;
  inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >*
      mutable_translation();

  // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedString)
 private:

  ::google::protobuf::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation > translation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  #endif
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

  void InitAsDefaultInstance();
  static TranslatedString* default_instance_;
};
// ===================================================================


// ===================================================================

// FeedMessage

// required .transit_realtime.FeedHeader header = 1;
inline bool FeedMessage::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeedMessage::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeedMessage::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeedMessage::clear_header() {
  if (header_ != NULL) header_->::transit_realtime::FeedHeader::Clear();
  clear_has_header();
}
inline const ::transit_realtime::FeedHeader& FeedMessage::header() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return header_ != NULL ? *header_ : *default_instance().header_;
#else
  return header_ != NULL ? *header_ : *default_instance_->header_;
#endif
}
inline ::transit_realtime::FeedHeader* FeedMessage::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::transit_realtime::FeedHeader;
  return header_;
}
inline ::transit_realtime::FeedHeader* FeedMessage::release_header() {
  clear_has_header();
  ::transit_realtime::FeedHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void FeedMessage::set_allocated_header(::transit_realtime::FeedHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// repeated .transit_realtime.FeedEntity entity = 2;
inline int FeedMessage::entity_size() const {
  return entity_.size();
}
inline void FeedMessage::clear_entity() {
  entity_.Clear();
}
inline const ::transit_realtime::FeedEntity& FeedMessage::entity(int index) const {
  return entity_.Get(index);
}
inline ::transit_realtime::FeedEntity* FeedMessage::mutable_entity(int index) {
  return entity_.Mutable(index);
}
inline ::transit_realtime::FeedEntity* FeedMessage::add_entity() {
  return entity_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::FeedEntity >&
FeedMessage::entity() const {
  return entity_;
}
inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::FeedEntity >*
FeedMessage::mutable_entity() {
  return &entity_;
}

// -------------------------------------------------------------------

// FeedHeader

// required string gtfs_realtime_version = 1;
inline bool FeedHeader::has_gtfs_realtime_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeedHeader::set_has_gtfs_realtime_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeedHeader::clear_has_gtfs_realtime_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeedHeader::clear_gtfs_realtime_version() {
  if (gtfs_realtime_version_ != &::google::protobuf::internal::kEmptyString) {
    gtfs_realtime_version_->clear();
  }
  clear_has_gtfs_realtime_version();
}
inline const ::std::string& FeedHeader::gtfs_realtime_version() const {
  return *gtfs_realtime_version_;
}
inline void FeedHeader::set_gtfs_realtime_version(const ::std::string& value) {
  set_has_gtfs_realtime_version();
  if (gtfs_realtime_version_ == &::google::protobuf::internal::kEmptyString) {
    gtfs_realtime_version_ = new ::std::string;
  }
  gtfs_realtime_version_->assign(value);
}
inline void FeedHeader::set_gtfs_realtime_version(const char* value) {
  set_has_gtfs_realtime_version();
  if (gtfs_realtime_version_ == &::google::protobuf::internal::kEmptyString) {
    gtfs_realtime_version_ = new ::std::string;
  }
  gtfs_realtime_version_->assign(value);
}
inline void FeedHeader::set_gtfs_realtime_version(const char* value, size_t size) {
  set_has_gtfs_realtime_version();
  if (gtfs_realtime_version_ == &::google::protobuf::internal::kEmptyString) {
    gtfs_realtime_version_ = new ::std::string;
  }
  gtfs_realtime_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeedHeader::mutable_gtfs_realtime_version() {
  set_has_gtfs_realtime_version();
  if (gtfs_realtime_version_ == &::google::protobuf::internal::kEmptyString) {
    gtfs_realtime_version_ = new ::std::string;
  }
  return gtfs_realtime_version_;
}
inline ::std::string* FeedHeader::release_gtfs_realtime_version() {
  clear_has_gtfs_realtime_version();
  if (gtfs_realtime_version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gtfs_realtime_version_;
    gtfs_realtime_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FeedHeader::set_allocated_gtfs_realtime_version(::std::string* gtfs_realtime_version) {
  if (gtfs_realtime_version_ != &::google::protobuf::internal::kEmptyString) {
    delete gtfs_realtime_version_;
  }
  if (gtfs_realtime_version) {
    set_has_gtfs_realtime_version();
    gtfs_realtime_version_ = gtfs_realtime_version;
  } else {
    clear_has_gtfs_realtime_version();
    gtfs_realtime_version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];
inline bool FeedHeader::has_incrementality() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeedHeader::set_has_incrementality() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeedHeader::clear_has_incrementality() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FeedHeader::clear_incrementality() {
  incrementality_ = 0;
  clear_has_incrementality();
}
inline ::transit_realtime::FeedHeader_Incrementality FeedHeader::incrementality() const {
  return static_cast< ::transit_realtime::FeedHeader_Incrementality >(incrementality_);
}
inline void FeedHeader::set_incrementality(::transit_realtime::FeedHeader_Incrementality value) {
  assert(::transit_realtime::FeedHeader_Incrementality_IsValid(value));
  set_has_incrementality();
  incrementality_ = value;
}

// optional uint64 timestamp = 3;
inline bool FeedHeader::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FeedHeader::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FeedHeader::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FeedHeader::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 FeedHeader::timestamp() const {
  return timestamp_;
}
inline void FeedHeader::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// FeedEntity

// required string id = 1;
inline bool FeedEntity::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeedEntity::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeedEntity::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeedEntity::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& FeedEntity::id() const {
  return *id_;
}
inline void FeedEntity::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void FeedEntity::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void FeedEntity::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeedEntity::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* FeedEntity::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FeedEntity::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool is_deleted = 2 [default = false];
inline bool FeedEntity::has_is_deleted() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeedEntity::set_has_is_deleted() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeedEntity::clear_has_is_deleted() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FeedEntity::clear_is_deleted() {
  is_deleted_ = false;
  clear_has_is_deleted();
}
inline bool FeedEntity::is_deleted() const {
  return is_deleted_;
}
inline void FeedEntity::set_is_deleted(bool value) {
  set_has_is_deleted();
  is_deleted_ = value;
}

// optional .transit_realtime.TripUpdate trip_update = 3;
inline bool FeedEntity::has_trip_update() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FeedEntity::set_has_trip_update() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FeedEntity::clear_has_trip_update() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FeedEntity::clear_trip_update() {
  if (trip_update_ != NULL) trip_update_->::transit_realtime::TripUpdate::Clear();
  clear_has_trip_update();
}
inline const ::transit_realtime::TripUpdate& FeedEntity::trip_update() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trip_update_ != NULL ? *trip_update_ : *default_instance().trip_update_;
#else
  return trip_update_ != NULL ? *trip_update_ : *default_instance_->trip_update_;
#endif
}
inline ::transit_realtime::TripUpdate* FeedEntity::mutable_trip_update() {
  set_has_trip_update();
  if (trip_update_ == NULL) trip_update_ = new ::transit_realtime::TripUpdate;
  return trip_update_;
}
inline ::transit_realtime::TripUpdate* FeedEntity::release_trip_update() {
  clear_has_trip_update();
  ::transit_realtime::TripUpdate* temp = trip_update_;
  trip_update_ = NULL;
  return temp;
}
inline void FeedEntity::set_allocated_trip_update(::transit_realtime::TripUpdate* trip_update) {
  delete trip_update_;
  trip_update_ = trip_update;
  if (trip_update) {
    set_has_trip_update();
  } else {
    clear_has_trip_update();
  }
}

// optional .transit_realtime.VehiclePosition vehicle = 4;
inline bool FeedEntity::has_vehicle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FeedEntity::set_has_vehicle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FeedEntity::clear_has_vehicle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FeedEntity::clear_vehicle() {
  if (vehicle_ != NULL) vehicle_->::transit_realtime::VehiclePosition::Clear();
  clear_has_vehicle();
}
inline const ::transit_realtime::VehiclePosition& FeedEntity::vehicle() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return vehicle_ != NULL ? *vehicle_ : *default_instance().vehicle_;
#else
  return vehicle_ != NULL ? *vehicle_ : *default_instance_->vehicle_;
#endif
}
inline ::transit_realtime::VehiclePosition* FeedEntity::mutable_vehicle() {
  set_has_vehicle();
  if (vehicle_ == NULL) vehicle_ = new ::transit_realtime::VehiclePosition;
  return vehicle_;
}
inline ::transit_realtime::VehiclePosition* FeedEntity::release_vehicle() {
  clear_has_vehicle();
  ::transit_realtime::VehiclePosition* temp = vehicle_;
  vehicle_ = NULL;
  return temp;
}
inline void FeedEntity::set_allocated_vehicle(::transit_realtime::VehiclePosition* vehicle) {
  delete vehicle_;
  vehicle_ = vehicle;
  if (vehicle) {
    set_has_vehicle();
  } else {
    clear_has_vehicle();
  }
}

// optional .transit_realtime.Alert alert = 5;
inline bool FeedEntity::has_alert() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FeedEntity::set_has_alert() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FeedEntity::clear_has_alert() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FeedEntity::clear_alert() {
  if (alert_ != NULL) alert_->::transit_realtime::Alert::Clear();
  clear_has_alert();
}
inline const ::transit_realtime::Alert& FeedEntity::alert() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return alert_ != NULL ? *alert_ : *default_instance().alert_;
#else
  return alert_ != NULL ? *alert_ : *default_instance_->alert_;
#endif
}
inline ::transit_realtime::Alert* FeedEntity::mutable_alert() {
  set_has_alert();
  if (alert_ == NULL) alert_ = new ::transit_realtime::Alert;
  return alert_;
}
inline ::transit_realtime::Alert* FeedEntity::release_alert() {
  clear_has_alert();
  ::transit_realtime::Alert* temp = alert_;
  alert_ = NULL;
  return temp;
}
inline void FeedEntity::set_allocated_alert(::transit_realtime::Alert* alert) {
  delete alert_;
  alert_ = alert;
  if (alert) {
    set_has_alert();
  } else {
    clear_has_alert();
  }
}

// -------------------------------------------------------------------

// TripUpdate_StopTimeEvent

// optional int32 delay = 1;
inline bool TripUpdate_StopTimeEvent::has_delay() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripUpdate_StopTimeEvent::set_has_delay() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripUpdate_StopTimeEvent::clear_has_delay() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripUpdate_StopTimeEvent::clear_delay() {
  delay_ = 0;
  clear_has_delay();
}
inline ::google::protobuf::int32 TripUpdate_StopTimeEvent::delay() const {
  return delay_;
}
inline void TripUpdate_StopTimeEvent::set_delay(::google::protobuf::int32 value) {
  set_has_delay();
  delay_ = value;
}

// optional int64 time = 2;
inline bool TripUpdate_StopTimeEvent::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripUpdate_StopTimeEvent::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripUpdate_StopTimeEvent::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripUpdate_StopTimeEvent::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 TripUpdate_StopTimeEvent::time() const {
  return time_;
}
inline void TripUpdate_StopTimeEvent::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// optional int32 uncertainty = 3;
inline bool TripUpdate_StopTimeEvent::has_uncertainty() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripUpdate_StopTimeEvent::set_has_uncertainty() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripUpdate_StopTimeEvent::clear_has_uncertainty() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripUpdate_StopTimeEvent::clear_uncertainty() {
  uncertainty_ = 0;
  clear_has_uncertainty();
}
inline ::google::protobuf::int32 TripUpdate_StopTimeEvent::uncertainty() const {
  return uncertainty_;
}
inline void TripUpdate_StopTimeEvent::set_uncertainty(::google::protobuf::int32 value) {
  set_has_uncertainty();
  uncertainty_ = value;
}

// -------------------------------------------------------------------

// TripUpdate_StopTimeUpdate

// optional uint32 stop_sequence = 1;
inline bool TripUpdate_StopTimeUpdate::has_stop_sequence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripUpdate_StopTimeUpdate::set_has_stop_sequence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripUpdate_StopTimeUpdate::clear_has_stop_sequence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripUpdate_StopTimeUpdate::clear_stop_sequence() {
  stop_sequence_ = 0u;
  clear_has_stop_sequence();
}
inline ::google::protobuf::uint32 TripUpdate_StopTimeUpdate::stop_sequence() const {
  return stop_sequence_;
}
inline void TripUpdate_StopTimeUpdate::set_stop_sequence(::google::protobuf::uint32 value) {
  set_has_stop_sequence();
  stop_sequence_ = value;
}

// optional string stop_id = 4;
inline bool TripUpdate_StopTimeUpdate::has_stop_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripUpdate_StopTimeUpdate::set_has_stop_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripUpdate_StopTimeUpdate::clear_has_stop_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripUpdate_StopTimeUpdate::clear_stop_id() {
  if (stop_id_ != &::google::protobuf::internal::kEmptyString) {
    stop_id_->clear();
  }
  clear_has_stop_id();
}
inline const ::std::string& TripUpdate_StopTimeUpdate::stop_id() const {
  return *stop_id_;
}
inline void TripUpdate_StopTimeUpdate::set_stop_id(const ::std::string& value) {
  set_has_stop_id();
  if (stop_id_ == &::google::protobuf::internal::kEmptyString) {
    stop_id_ = new ::std::string;
  }
  stop_id_->assign(value);
}
inline void TripUpdate_StopTimeUpdate::set_stop_id(const char* value) {
  set_has_stop_id();
  if (stop_id_ == &::google::protobuf::internal::kEmptyString) {
    stop_id_ = new ::std::string;
  }
  stop_id_->assign(value);
}
inline void TripUpdate_StopTimeUpdate::set_stop_id(const char* value, size_t size) {
  set_has_stop_id();
  if (stop_id_ == &::google::protobuf::internal::kEmptyString) {
    stop_id_ = new ::std::string;
  }
  stop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripUpdate_StopTimeUpdate::mutable_stop_id() {
  set_has_stop_id();
  if (stop_id_ == &::google::protobuf::internal::kEmptyString) {
    stop_id_ = new ::std::string;
  }
  return stop_id_;
}
inline ::std::string* TripUpdate_StopTimeUpdate::release_stop_id() {
  clear_has_stop_id();
  if (stop_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stop_id_;
    stop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripUpdate_StopTimeUpdate::set_allocated_stop_id(::std::string* stop_id) {
  if (stop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete stop_id_;
  }
  if (stop_id) {
    set_has_stop_id();
    stop_id_ = stop_id;
  } else {
    clear_has_stop_id();
    stop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;
inline bool TripUpdate_StopTimeUpdate::has_arrival() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripUpdate_StopTimeUpdate::set_has_arrival() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripUpdate_StopTimeUpdate::clear_has_arrival() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripUpdate_StopTimeUpdate::clear_arrival() {
  if (arrival_ != NULL) arrival_->::transit_realtime::TripUpdate_StopTimeEvent::Clear();
  clear_has_arrival();
}
inline const ::transit_realtime::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::arrival() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return arrival_ != NULL ? *arrival_ : *default_instance().arrival_;
#else
  return arrival_ != NULL ? *arrival_ : *default_instance_->arrival_;
#endif
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::mutable_arrival() {
  set_has_arrival();
  if (arrival_ == NULL) arrival_ = new ::transit_realtime::TripUpdate_StopTimeEvent;
  return arrival_;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::release_arrival() {
  clear_has_arrival();
  ::transit_realtime::TripUpdate_StopTimeEvent* temp = arrival_;
  arrival_ = NULL;
  return temp;
}
inline void TripUpdate_StopTimeUpdate::set_allocated_arrival(::transit_realtime::TripUpdate_StopTimeEvent* arrival) {
  delete arrival_;
  arrival_ = arrival;
  if (arrival) {
    set_has_arrival();
  } else {
    clear_has_arrival();
  }
}

// optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;
inline bool TripUpdate_StopTimeUpdate::has_departure() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripUpdate_StopTimeUpdate::set_has_departure() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripUpdate_StopTimeUpdate::clear_has_departure() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripUpdate_StopTimeUpdate::clear_departure() {
  if (departure_ != NULL) departure_->::transit_realtime::TripUpdate_StopTimeEvent::Clear();
  clear_has_departure();
}
inline const ::transit_realtime::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::departure() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return departure_ != NULL ? *departure_ : *default_instance().departure_;
#else
  return departure_ != NULL ? *departure_ : *default_instance_->departure_;
#endif
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::mutable_departure() {
  set_has_departure();
  if (departure_ == NULL) departure_ = new ::transit_realtime::TripUpdate_StopTimeEvent;
  return departure_;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::release_departure() {
  clear_has_departure();
  ::transit_realtime::TripUpdate_StopTimeEvent* temp = departure_;
  departure_ = NULL;
  return temp;
}
inline void TripUpdate_StopTimeUpdate::set_allocated_departure(::transit_realtime::TripUpdate_StopTimeEvent* departure) {
  delete departure_;
  departure_ = departure;
  if (departure) {
    set_has_departure();
  } else {
    clear_has_departure();
  }
}

// optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];
inline bool TripUpdate_StopTimeUpdate::has_schedule_relationship() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripUpdate_StopTimeUpdate::set_has_schedule_relationship() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripUpdate_StopTimeUpdate::clear_has_schedule_relationship() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripUpdate_StopTimeUpdate::clear_schedule_relationship() {
  schedule_relationship_ = 0;
  clear_has_schedule_relationship();
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate::schedule_relationship() const {
  return static_cast< ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship >(schedule_relationship_);
}
inline void TripUpdate_StopTimeUpdate::set_schedule_relationship(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship value) {
  assert(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(value));
  set_has_schedule_relationship();
  schedule_relationship_ = value;
}

// -------------------------------------------------------------------

// TripUpdate

// required .transit_realtime.TripDescriptor trip = 1;
inline bool TripUpdate::has_trip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripUpdate::set_has_trip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripUpdate::clear_has_trip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripUpdate::clear_trip() {
  if (trip_ != NULL) trip_->::transit_realtime::TripDescriptor::Clear();
  clear_has_trip();
}
inline const ::transit_realtime::TripDescriptor& TripUpdate::trip() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trip_ != NULL ? *trip_ : *default_instance().trip_;
#else
  return trip_ != NULL ? *trip_ : *default_instance_->trip_;
#endif
}
inline ::transit_realtime::TripDescriptor* TripUpdate::mutable_trip() {
  set_has_trip();
  if (trip_ == NULL) trip_ = new ::transit_realtime::TripDescriptor;
  return trip_;
}
inline ::transit_realtime::TripDescriptor* TripUpdate::release_trip() {
  clear_has_trip();
  ::transit_realtime::TripDescriptor* temp = trip_;
  trip_ = NULL;
  return temp;
}
inline void TripUpdate::set_allocated_trip(::transit_realtime::TripDescriptor* trip) {
  delete trip_;
  trip_ = trip;
  if (trip) {
    set_has_trip();
  } else {
    clear_has_trip();
  }
}

// optional .transit_realtime.VehicleDescriptor vehicle = 3;
inline bool TripUpdate::has_vehicle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripUpdate::set_has_vehicle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripUpdate::clear_has_vehicle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripUpdate::clear_vehicle() {
  if (vehicle_ != NULL) vehicle_->::transit_realtime::VehicleDescriptor::Clear();
  clear_has_vehicle();
}
inline const ::transit_realtime::VehicleDescriptor& TripUpdate::vehicle() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return vehicle_ != NULL ? *vehicle_ : *default_instance().vehicle_;
#else
  return vehicle_ != NULL ? *vehicle_ : *default_instance_->vehicle_;
#endif
}
inline ::transit_realtime::VehicleDescriptor* TripUpdate::mutable_vehicle() {
  set_has_vehicle();
  if (vehicle_ == NULL) vehicle_ = new ::transit_realtime::VehicleDescriptor;
  return vehicle_;
}
inline ::transit_realtime::VehicleDescriptor* TripUpdate::release_vehicle() {
  clear_has_vehicle();
  ::transit_realtime::VehicleDescriptor* temp = vehicle_;
  vehicle_ = NULL;
  return temp;
}
inline void TripUpdate::set_allocated_vehicle(::transit_realtime::VehicleDescriptor* vehicle) {
  delete vehicle_;
  vehicle_ = vehicle;
  if (vehicle) {
    set_has_vehicle();
  } else {
    clear_has_vehicle();
  }
}

// repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;
inline int TripUpdate::stop_time_update_size() const {
  return stop_time_update_.size();
}
inline void TripUpdate::clear_stop_time_update() {
  stop_time_update_.Clear();
}
inline const ::transit_realtime::TripUpdate_StopTimeUpdate& TripUpdate::stop_time_update(int index) const {
  return stop_time_update_.Get(index);
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate* TripUpdate::mutable_stop_time_update(int index) {
  return stop_time_update_.Mutable(index);
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate* TripUpdate::add_stop_time_update() {
  return stop_time_update_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >&
TripUpdate::stop_time_update() const {
  return stop_time_update_;
}
inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >*
TripUpdate::mutable_stop_time_update() {
  return &stop_time_update_;
}

// optional uint64 timestamp = 4;
inline bool TripUpdate::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripUpdate::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripUpdate::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripUpdate::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 TripUpdate::timestamp() const {
  return timestamp_;
}
inline void TripUpdate::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// VehiclePosition

// optional .transit_realtime.TripDescriptor trip = 1;
inline bool VehiclePosition::has_trip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehiclePosition::set_has_trip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehiclePosition::clear_has_trip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehiclePosition::clear_trip() {
  if (trip_ != NULL) trip_->::transit_realtime::TripDescriptor::Clear();
  clear_has_trip();
}
inline const ::transit_realtime::TripDescriptor& VehiclePosition::trip() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trip_ != NULL ? *trip_ : *default_instance().trip_;
#else
  return trip_ != NULL ? *trip_ : *default_instance_->trip_;
#endif
}
inline ::transit_realtime::TripDescriptor* VehiclePosition::mutable_trip() {
  set_has_trip();
  if (trip_ == NULL) trip_ = new ::transit_realtime::TripDescriptor;
  return trip_;
}
inline ::transit_realtime::TripDescriptor* VehiclePosition::release_trip() {
  clear_has_trip();
  ::transit_realtime::TripDescriptor* temp = trip_;
  trip_ = NULL;
  return temp;
}
inline void VehiclePosition::set_allocated_trip(::transit_realtime::TripDescriptor* trip) {
  delete trip_;
  trip_ = trip;
  if (trip) {
    set_has_trip();
  } else {
    clear_has_trip();
  }
}

// optional .transit_realtime.VehicleDescriptor vehicle = 8;
inline bool VehiclePosition::has_vehicle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehiclePosition::set_has_vehicle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehiclePosition::clear_has_vehicle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehiclePosition::clear_vehicle() {
  if (vehicle_ != NULL) vehicle_->::transit_realtime::VehicleDescriptor::Clear();
  clear_has_vehicle();
}
inline const ::transit_realtime::VehicleDescriptor& VehiclePosition::vehicle() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return vehicle_ != NULL ? *vehicle_ : *default_instance().vehicle_;
#else
  return vehicle_ != NULL ? *vehicle_ : *default_instance_->vehicle_;
#endif
}
inline ::transit_realtime::VehicleDescriptor* VehiclePosition::mutable_vehicle() {
  set_has_vehicle();
  if (vehicle_ == NULL) vehicle_ = new ::transit_realtime::VehicleDescriptor;
  return vehicle_;
}
inline ::transit_realtime::VehicleDescriptor* VehiclePosition::release_vehicle() {
  clear_has_vehicle();
  ::transit_realtime::VehicleDescriptor* temp = vehicle_;
  vehicle_ = NULL;
  return temp;
}
inline void VehiclePosition::set_allocated_vehicle(::transit_realtime::VehicleDescriptor* vehicle) {
  delete vehicle_;
  vehicle_ = vehicle;
  if (vehicle) {
    set_has_vehicle();
  } else {
    clear_has_vehicle();
  }
}

// optional .transit_realtime.Position position = 2;
inline bool VehiclePosition::has_position() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehiclePosition::set_has_position() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehiclePosition::clear_has_position() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehiclePosition::clear_position() {
  if (position_ != NULL) position_->::transit_realtime::Position::Clear();
  clear_has_position();
}
inline const ::transit_realtime::Position& VehiclePosition::position() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return position_ != NULL ? *position_ : *default_instance().position_;
#else
  return position_ != NULL ? *position_ : *default_instance_->position_;
#endif
}
inline ::transit_realtime::Position* VehiclePosition::mutable_position() {
  set_has_position();
  if (position_ == NULL) position_ = new ::transit_realtime::Position;
  return position_;
}
inline ::transit_realtime::Position* VehiclePosition::release_position() {
  clear_has_position();
  ::transit_realtime::Position* temp = position_;
  position_ = NULL;
  return temp;
}
inline void VehiclePosition::set_allocated_position(::transit_realtime::Position* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
}

// optional uint32 current_stop_sequence = 3;
inline bool VehiclePosition::has_current_stop_sequence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehiclePosition::set_has_current_stop_sequence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehiclePosition::clear_has_current_stop_sequence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehiclePosition::clear_current_stop_sequence() {
  current_stop_sequence_ = 0u;
  clear_has_current_stop_sequence();
}
inline ::google::protobuf::uint32 VehiclePosition::current_stop_sequence() const {
  return current_stop_sequence_;
}
inline void VehiclePosition::set_current_stop_sequence(::google::protobuf::uint32 value) {
  set_has_current_stop_sequence();
  current_stop_sequence_ = value;
}

// optional string stop_id = 7;
inline bool VehiclePosition::has_stop_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehiclePosition::set_has_stop_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehiclePosition::clear_has_stop_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehiclePosition::clear_stop_id() {
  if (stop_id_ != &::google::protobuf::internal::kEmptyString) {
    stop_id_->clear();
  }
  clear_has_stop_id();
}
inline const ::std::string& VehiclePosition::stop_id() const {
  return *stop_id_;
}
inline void VehiclePosition::set_stop_id(const ::std::string& value) {
  set_has_stop_id();
  if (stop_id_ == &::google::protobuf::internal::kEmptyString) {
    stop_id_ = new ::std::string;
  }
  stop_id_->assign(value);
}
inline void VehiclePosition::set_stop_id(const char* value) {
  set_has_stop_id();
  if (stop_id_ == &::google::protobuf::internal::kEmptyString) {
    stop_id_ = new ::std::string;
  }
  stop_id_->assign(value);
}
inline void VehiclePosition::set_stop_id(const char* value, size_t size) {
  set_has_stop_id();
  if (stop_id_ == &::google::protobuf::internal::kEmptyString) {
    stop_id_ = new ::std::string;
  }
  stop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VehiclePosition::mutable_stop_id() {
  set_has_stop_id();
  if (stop_id_ == &::google::protobuf::internal::kEmptyString) {
    stop_id_ = new ::std::string;
  }
  return stop_id_;
}
inline ::std::string* VehiclePosition::release_stop_id() {
  clear_has_stop_id();
  if (stop_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stop_id_;
    stop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VehiclePosition::set_allocated_stop_id(::std::string* stop_id) {
  if (stop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete stop_id_;
  }
  if (stop_id) {
    set_has_stop_id();
    stop_id_ = stop_id;
  } else {
    clear_has_stop_id();
    stop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];
inline bool VehiclePosition::has_current_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void VehiclePosition::set_has_current_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void VehiclePosition::clear_has_current_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void VehiclePosition::clear_current_status() {
  current_status_ = 2;
  clear_has_current_status();
}
inline ::transit_realtime::VehiclePosition_VehicleStopStatus VehiclePosition::current_status() const {
  return static_cast< ::transit_realtime::VehiclePosition_VehicleStopStatus >(current_status_);
}
inline void VehiclePosition::set_current_status(::transit_realtime::VehiclePosition_VehicleStopStatus value) {
  assert(::transit_realtime::VehiclePosition_VehicleStopStatus_IsValid(value));
  set_has_current_status();
  current_status_ = value;
}

// optional uint64 timestamp = 5;
inline bool VehiclePosition::has_timestamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void VehiclePosition::set_has_timestamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void VehiclePosition::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void VehiclePosition::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 VehiclePosition::timestamp() const {
  return timestamp_;
}
inline void VehiclePosition::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;
inline bool VehiclePosition::has_congestion_level() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void VehiclePosition::set_has_congestion_level() {
  _has_bits_[0] |= 0x00000080u;
}
inline void VehiclePosition::clear_has_congestion_level() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void VehiclePosition::clear_congestion_level() {
  congestion_level_ = 0;
  clear_has_congestion_level();
}
inline ::transit_realtime::VehiclePosition_CongestionLevel VehiclePosition::congestion_level() const {
  return static_cast< ::transit_realtime::VehiclePosition_CongestionLevel >(congestion_level_);
}
inline void VehiclePosition::set_congestion_level(::transit_realtime::VehiclePosition_CongestionLevel value) {
  assert(::transit_realtime::VehiclePosition_CongestionLevel_IsValid(value));
  set_has_congestion_level();
  congestion_level_ = value;
}

// -------------------------------------------------------------------

// Alert

// repeated .transit_realtime.TimeRange active_period = 1;
inline int Alert::active_period_size() const {
  return active_period_.size();
}
inline void Alert::clear_active_period() {
  active_period_.Clear();
}
inline const ::transit_realtime::TimeRange& Alert::active_period(int index) const {
  return active_period_.Get(index);
}
inline ::transit_realtime::TimeRange* Alert::mutable_active_period(int index) {
  return active_period_.Mutable(index);
}
inline ::transit_realtime::TimeRange* Alert::add_active_period() {
  return active_period_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange >&
Alert::active_period() const {
  return active_period_;
}
inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange >*
Alert::mutable_active_period() {
  return &active_period_;
}

// repeated .transit_realtime.EntitySelector informed_entity = 5;
inline int Alert::informed_entity_size() const {
  return informed_entity_.size();
}
inline void Alert::clear_informed_entity() {
  informed_entity_.Clear();
}
inline const ::transit_realtime::EntitySelector& Alert::informed_entity(int index) const {
  return informed_entity_.Get(index);
}
inline ::transit_realtime::EntitySelector* Alert::mutable_informed_entity(int index) {
  return informed_entity_.Mutable(index);
}
inline ::transit_realtime::EntitySelector* Alert::add_informed_entity() {
  return informed_entity_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::EntitySelector >&
Alert::informed_entity() const {
  return informed_entity_;
}
inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::EntitySelector >*
Alert::mutable_informed_entity() {
  return &informed_entity_;
}

// optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];
inline bool Alert::has_cause() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Alert::set_has_cause() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Alert::clear_has_cause() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Alert::clear_cause() {
  cause_ = 1;
  clear_has_cause();
}
inline ::transit_realtime::Alert_Cause Alert::cause() const {
  return static_cast< ::transit_realtime::Alert_Cause >(cause_);
}
inline void Alert::set_cause(::transit_realtime::Alert_Cause value) {
  assert(::transit_realtime::Alert_Cause_IsValid(value));
  set_has_cause();
  cause_ = value;
}

// optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];
inline bool Alert::has_effect() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Alert::set_has_effect() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Alert::clear_has_effect() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Alert::clear_effect() {
  effect_ = 8;
  clear_has_effect();
}
inline ::transit_realtime::Alert_Effect Alert::effect() const {
  return static_cast< ::transit_realtime::Alert_Effect >(effect_);
}
inline void Alert::set_effect(::transit_realtime::Alert_Effect value) {
  assert(::transit_realtime::Alert_Effect_IsValid(value));
  set_has_effect();
  effect_ = value;
}

// optional .transit_realtime.TranslatedString url = 8;
inline bool Alert::has_url() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Alert::set_has_url() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Alert::clear_has_url() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Alert::clear_url() {
  if (url_ != NULL) url_->::transit_realtime::TranslatedString::Clear();
  clear_has_url();
}
inline const ::transit_realtime::TranslatedString& Alert::url() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return url_ != NULL ? *url_ : *default_instance().url_;
#else
  return url_ != NULL ? *url_ : *default_instance_->url_;
#endif
}
inline ::transit_realtime::TranslatedString* Alert::mutable_url() {
  set_has_url();
  if (url_ == NULL) url_ = new ::transit_realtime::TranslatedString;
  return url_;
}
inline ::transit_realtime::TranslatedString* Alert::release_url() {
  clear_has_url();
  ::transit_realtime::TranslatedString* temp = url_;
  url_ = NULL;
  return temp;
}
inline void Alert::set_allocated_url(::transit_realtime::TranslatedString* url) {
  delete url_;
  url_ = url;
  if (url) {
    set_has_url();
  } else {
    clear_has_url();
  }
}

// optional .transit_realtime.TranslatedString header_text = 10;
inline bool Alert::has_header_text() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Alert::set_has_header_text() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Alert::clear_has_header_text() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Alert::clear_header_text() {
  if (header_text_ != NULL) header_text_->::transit_realtime::TranslatedString::Clear();
  clear_has_header_text();
}
inline const ::transit_realtime::TranslatedString& Alert::header_text() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return header_text_ != NULL ? *header_text_ : *default_instance().header_text_;
#else
  return header_text_ != NULL ? *header_text_ : *default_instance_->header_text_;
#endif
}
inline ::transit_realtime::TranslatedString* Alert::mutable_header_text() {
  set_has_header_text();
  if (header_text_ == NULL) header_text_ = new ::transit_realtime::TranslatedString;
  return header_text_;
}
inline ::transit_realtime::TranslatedString* Alert::release_header_text() {
  clear_has_header_text();
  ::transit_realtime::TranslatedString* temp = header_text_;
  header_text_ = NULL;
  return temp;
}
inline void Alert::set_allocated_header_text(::transit_realtime::TranslatedString* header_text) {
  delete header_text_;
  header_text_ = header_text;
  if (header_text) {
    set_has_header_text();
  } else {
    clear_has_header_text();
  }
}

// optional .transit_realtime.TranslatedString description_text = 11;
inline bool Alert::has_description_text() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Alert::set_has_description_text() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Alert::clear_has_description_text() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Alert::clear_description_text() {
  if (description_text_ != NULL) description_text_->::transit_realtime::TranslatedString::Clear();
  clear_has_description_text();
}
inline const ::transit_realtime::TranslatedString& Alert::description_text() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return description_text_ != NULL ? *description_text_ : *default_instance().description_text_;
#else
  return description_text_ != NULL ? *description_text_ : *default_instance_->description_text_;
#endif
}
inline ::transit_realtime::TranslatedString* Alert::mutable_description_text() {
  set_has_description_text();
  if (description_text_ == NULL) description_text_ = new ::transit_realtime::TranslatedString;
  return description_text_;
}
inline ::transit_realtime::TranslatedString* Alert::release_description_text() {
  clear_has_description_text();
  ::transit_realtime::TranslatedString* temp = description_text_;
  description_text_ = NULL;
  return temp;
}
inline void Alert::set_allocated_description_text(::transit_realtime::TranslatedString* description_text) {
  delete description_text_;
  description_text_ = description_text;
  if (description_text) {
    set_has_description_text();
  } else {
    clear_has_description_text();
  }
}

// -------------------------------------------------------------------

// TimeRange

// optional uint64 start = 1;
inline bool TimeRange::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeRange::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeRange::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeRange::clear_start() {
  start_ = GOOGLE_ULONGLONG(0);
  clear_has_start();
}
inline ::google::protobuf::uint64 TimeRange::start() const {
  return start_;
}
inline void TimeRange::set_start(::google::protobuf::uint64 value) {
  set_has_start();
  start_ = value;
}

// optional uint64 end = 2;
inline bool TimeRange::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeRange::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeRange::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeRange::clear_end() {
  end_ = GOOGLE_ULONGLONG(0);
  clear_has_end();
}
inline ::google::protobuf::uint64 TimeRange::end() const {
  return end_;
}
inline void TimeRange::set_end(::google::protobuf::uint64 value) {
  set_has_end();
  end_ = value;
}

// -------------------------------------------------------------------

// Position

// required float latitude = 1;
inline bool Position::has_latitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_latitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline float Position::latitude() const {
  return latitude_;
}
inline void Position::set_latitude(float value) {
  set_has_latitude();
  latitude_ = value;
}

// required float longitude = 2;
inline bool Position::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_longitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline float Position::longitude() const {
  return longitude_;
}
inline void Position::set_longitude(float value) {
  set_has_longitude();
  longitude_ = value;
}

// optional float bearing = 3;
inline bool Position::has_bearing() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Position::set_has_bearing() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Position::clear_has_bearing() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Position::clear_bearing() {
  bearing_ = 0;
  clear_has_bearing();
}
inline float Position::bearing() const {
  return bearing_;
}
inline void Position::set_bearing(float value) {
  set_has_bearing();
  bearing_ = value;
}

// optional double odometer = 4;
inline bool Position::has_odometer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Position::set_has_odometer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Position::clear_has_odometer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Position::clear_odometer() {
  odometer_ = 0;
  clear_has_odometer();
}
inline double Position::odometer() const {
  return odometer_;
}
inline void Position::set_odometer(double value) {
  set_has_odometer();
  odometer_ = value;
}

// optional float speed = 5;
inline bool Position::has_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Position::set_has_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Position::clear_has_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Position::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float Position::speed() const {
  return speed_;
}
inline void Position::set_speed(float value) {
  set_has_speed();
  speed_ = value;
}

// -------------------------------------------------------------------

// TripDescriptor

// optional string trip_id = 1;
inline bool TripDescriptor::has_trip_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TripDescriptor::set_has_trip_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TripDescriptor::clear_has_trip_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TripDescriptor::clear_trip_id() {
  if (trip_id_ != &::google::protobuf::internal::kEmptyString) {
    trip_id_->clear();
  }
  clear_has_trip_id();
}
inline const ::std::string& TripDescriptor::trip_id() const {
  return *trip_id_;
}
inline void TripDescriptor::set_trip_id(const ::std::string& value) {
  set_has_trip_id();
  if (trip_id_ == &::google::protobuf::internal::kEmptyString) {
    trip_id_ = new ::std::string;
  }
  trip_id_->assign(value);
}
inline void TripDescriptor::set_trip_id(const char* value) {
  set_has_trip_id();
  if (trip_id_ == &::google::protobuf::internal::kEmptyString) {
    trip_id_ = new ::std::string;
  }
  trip_id_->assign(value);
}
inline void TripDescriptor::set_trip_id(const char* value, size_t size) {
  set_has_trip_id();
  if (trip_id_ == &::google::protobuf::internal::kEmptyString) {
    trip_id_ = new ::std::string;
  }
  trip_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDescriptor::mutable_trip_id() {
  set_has_trip_id();
  if (trip_id_ == &::google::protobuf::internal::kEmptyString) {
    trip_id_ = new ::std::string;
  }
  return trip_id_;
}
inline ::std::string* TripDescriptor::release_trip_id() {
  clear_has_trip_id();
  if (trip_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trip_id_;
    trip_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDescriptor::set_allocated_trip_id(::std::string* trip_id) {
  if (trip_id_ != &::google::protobuf::internal::kEmptyString) {
    delete trip_id_;
  }
  if (trip_id) {
    set_has_trip_id();
    trip_id_ = trip_id;
  } else {
    clear_has_trip_id();
    trip_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string route_id = 5;
inline bool TripDescriptor::has_route_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TripDescriptor::set_has_route_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TripDescriptor::clear_has_route_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TripDescriptor::clear_route_id() {
  if (route_id_ != &::google::protobuf::internal::kEmptyString) {
    route_id_->clear();
  }
  clear_has_route_id();
}
inline const ::std::string& TripDescriptor::route_id() const {
  return *route_id_;
}
inline void TripDescriptor::set_route_id(const ::std::string& value) {
  set_has_route_id();
  if (route_id_ == &::google::protobuf::internal::kEmptyString) {
    route_id_ = new ::std::string;
  }
  route_id_->assign(value);
}
inline void TripDescriptor::set_route_id(const char* value) {
  set_has_route_id();
  if (route_id_ == &::google::protobuf::internal::kEmptyString) {
    route_id_ = new ::std::string;
  }
  route_id_->assign(value);
}
inline void TripDescriptor::set_route_id(const char* value, size_t size) {
  set_has_route_id();
  if (route_id_ == &::google::protobuf::internal::kEmptyString) {
    route_id_ = new ::std::string;
  }
  route_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDescriptor::mutable_route_id() {
  set_has_route_id();
  if (route_id_ == &::google::protobuf::internal::kEmptyString) {
    route_id_ = new ::std::string;
  }
  return route_id_;
}
inline ::std::string* TripDescriptor::release_route_id() {
  clear_has_route_id();
  if (route_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = route_id_;
    route_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDescriptor::set_allocated_route_id(::std::string* route_id) {
  if (route_id_ != &::google::protobuf::internal::kEmptyString) {
    delete route_id_;
  }
  if (route_id) {
    set_has_route_id();
    route_id_ = route_id;
  } else {
    clear_has_route_id();
    route_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string start_time = 2;
inline bool TripDescriptor::has_start_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TripDescriptor::set_has_start_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TripDescriptor::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TripDescriptor::clear_start_time() {
  if (start_time_ != &::google::protobuf::internal::kEmptyString) {
    start_time_->clear();
  }
  clear_has_start_time();
}
inline const ::std::string& TripDescriptor::start_time() const {
  return *start_time_;
}
inline void TripDescriptor::set_start_time(const ::std::string& value) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
}
inline void TripDescriptor::set_start_time(const char* value) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
}
inline void TripDescriptor::set_start_time(const char* value, size_t size) {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDescriptor::mutable_start_time() {
  set_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    start_time_ = new ::std::string;
  }
  return start_time_;
}
inline ::std::string* TripDescriptor::release_start_time() {
  clear_has_start_time();
  if (start_time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = start_time_;
    start_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDescriptor::set_allocated_start_time(::std::string* start_time) {
  if (start_time_ != &::google::protobuf::internal::kEmptyString) {
    delete start_time_;
  }
  if (start_time) {
    set_has_start_time();
    start_time_ = start_time;
  } else {
    clear_has_start_time();
    start_time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string start_date = 3;
inline bool TripDescriptor::has_start_date() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TripDescriptor::set_has_start_date() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TripDescriptor::clear_has_start_date() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TripDescriptor::clear_start_date() {
  if (start_date_ != &::google::protobuf::internal::kEmptyString) {
    start_date_->clear();
  }
  clear_has_start_date();
}
inline const ::std::string& TripDescriptor::start_date() const {
  return *start_date_;
}
inline void TripDescriptor::set_start_date(const ::std::string& value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::kEmptyString) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
}
inline void TripDescriptor::set_start_date(const char* value) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::kEmptyString) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
}
inline void TripDescriptor::set_start_date(const char* value, size_t size) {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::kEmptyString) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDescriptor::mutable_start_date() {
  set_has_start_date();
  if (start_date_ == &::google::protobuf::internal::kEmptyString) {
    start_date_ = new ::std::string;
  }
  return start_date_;
}
inline ::std::string* TripDescriptor::release_start_date() {
  clear_has_start_date();
  if (start_date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = start_date_;
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TripDescriptor::set_allocated_start_date(::std::string* start_date) {
  if (start_date_ != &::google::protobuf::internal::kEmptyString) {
    delete start_date_;
  }
  if (start_date) {
    set_has_start_date();
    start_date_ = start_date;
  } else {
    clear_has_start_date();
    start_date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
inline bool TripDescriptor::has_schedule_relationship() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TripDescriptor::set_has_schedule_relationship() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TripDescriptor::clear_has_schedule_relationship() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TripDescriptor::clear_schedule_relationship() {
  schedule_relationship_ = 0;
  clear_has_schedule_relationship();
}
inline ::transit_realtime::TripDescriptor_ScheduleRelationship TripDescriptor::schedule_relationship() const {
  return static_cast< ::transit_realtime::TripDescriptor_ScheduleRelationship >(schedule_relationship_);
}
inline void TripDescriptor::set_schedule_relationship(::transit_realtime::TripDescriptor_ScheduleRelationship value) {
  assert(::transit_realtime::TripDescriptor_ScheduleRelationship_IsValid(value));
  set_has_schedule_relationship();
  schedule_relationship_ = value;
}

// -------------------------------------------------------------------

// VehicleDescriptor

// optional string id = 1;
inline bool VehicleDescriptor::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehicleDescriptor::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehicleDescriptor::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehicleDescriptor::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& VehicleDescriptor::id() const {
  return *id_;
}
inline void VehicleDescriptor::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void VehicleDescriptor::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void VehicleDescriptor::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VehicleDescriptor::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* VehicleDescriptor::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VehicleDescriptor::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string label = 2;
inline bool VehicleDescriptor::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehicleDescriptor::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehicleDescriptor::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehicleDescriptor::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& VehicleDescriptor::label() const {
  return *label_;
}
inline void VehicleDescriptor::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void VehicleDescriptor::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void VehicleDescriptor::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VehicleDescriptor::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* VehicleDescriptor::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VehicleDescriptor::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string license_plate = 3;
inline bool VehicleDescriptor::has_license_plate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehicleDescriptor::set_has_license_plate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehicleDescriptor::clear_has_license_plate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehicleDescriptor::clear_license_plate() {
  if (license_plate_ != &::google::protobuf::internal::kEmptyString) {
    license_plate_->clear();
  }
  clear_has_license_plate();
}
inline const ::std::string& VehicleDescriptor::license_plate() const {
  return *license_plate_;
}
inline void VehicleDescriptor::set_license_plate(const ::std::string& value) {
  set_has_license_plate();
  if (license_plate_ == &::google::protobuf::internal::kEmptyString) {
    license_plate_ = new ::std::string;
  }
  license_plate_->assign(value);
}
inline void VehicleDescriptor::set_license_plate(const char* value) {
  set_has_license_plate();
  if (license_plate_ == &::google::protobuf::internal::kEmptyString) {
    license_plate_ = new ::std::string;
  }
  license_plate_->assign(value);
}
inline void VehicleDescriptor::set_license_plate(const char* value, size_t size) {
  set_has_license_plate();
  if (license_plate_ == &::google::protobuf::internal::kEmptyString) {
    license_plate_ = new ::std::string;
  }
  license_plate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VehicleDescriptor::mutable_license_plate() {
  set_has_license_plate();
  if (license_plate_ == &::google::protobuf::internal::kEmptyString) {
    license_plate_ = new ::std::string;
  }
  return license_plate_;
}
inline ::std::string* VehicleDescriptor::release_license_plate() {
  clear_has_license_plate();
  if (license_plate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = license_plate_;
    license_plate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void VehicleDescriptor::set_allocated_license_plate(::std::string* license_plate) {
  if (license_plate_ != &::google::protobuf::internal::kEmptyString) {
    delete license_plate_;
  }
  if (license_plate) {
    set_has_license_plate();
    license_plate_ = license_plate;
  } else {
    clear_has_license_plate();
    license_plate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// EntitySelector

// optional string agency_id = 1;
inline bool EntitySelector::has_agency_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntitySelector::set_has_agency_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntitySelector::clear_has_agency_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntitySelector::clear_agency_id() {
  if (agency_id_ != &::google::protobuf::internal::kEmptyString) {
    agency_id_->clear();
  }
  clear_has_agency_id();
}
inline const ::std::string& EntitySelector::agency_id() const {
  return *agency_id_;
}
inline void EntitySelector::set_agency_id(const ::std::string& value) {
  set_has_agency_id();
  if (agency_id_ == &::google::protobuf::internal::kEmptyString) {
    agency_id_ = new ::std::string;
  }
  agency_id_->assign(value);
}
inline void EntitySelector::set_agency_id(const char* value) {
  set_has_agency_id();
  if (agency_id_ == &::google::protobuf::internal::kEmptyString) {
    agency_id_ = new ::std::string;
  }
  agency_id_->assign(value);
}
inline void EntitySelector::set_agency_id(const char* value, size_t size) {
  set_has_agency_id();
  if (agency_id_ == &::google::protobuf::internal::kEmptyString) {
    agency_id_ = new ::std::string;
  }
  agency_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EntitySelector::mutable_agency_id() {
  set_has_agency_id();
  if (agency_id_ == &::google::protobuf::internal::kEmptyString) {
    agency_id_ = new ::std::string;
  }
  return agency_id_;
}
inline ::std::string* EntitySelector::release_agency_id() {
  clear_has_agency_id();
  if (agency_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agency_id_;
    agency_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EntitySelector::set_allocated_agency_id(::std::string* agency_id) {
  if (agency_id_ != &::google::protobuf::internal::kEmptyString) {
    delete agency_id_;
  }
  if (agency_id) {
    set_has_agency_id();
    agency_id_ = agency_id;
  } else {
    clear_has_agency_id();
    agency_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string route_id = 2;
inline bool EntitySelector::has_route_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EntitySelector::set_has_route_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EntitySelector::clear_has_route_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EntitySelector::clear_route_id() {
  if (route_id_ != &::google::protobuf::internal::kEmptyString) {
    route_id_->clear();
  }
  clear_has_route_id();
}
inline const ::std::string& EntitySelector::route_id() const {
  return *route_id_;
}
inline void EntitySelector::set_route_id(const ::std::string& value) {
  set_has_route_id();
  if (route_id_ == &::google::protobuf::internal::kEmptyString) {
    route_id_ = new ::std::string;
  }
  route_id_->assign(value);
}
inline void EntitySelector::set_route_id(const char* value) {
  set_has_route_id();
  if (route_id_ == &::google::protobuf::internal::kEmptyString) {
    route_id_ = new ::std::string;
  }
  route_id_->assign(value);
}
inline void EntitySelector::set_route_id(const char* value, size_t size) {
  set_has_route_id();
  if (route_id_ == &::google::protobuf::internal::kEmptyString) {
    route_id_ = new ::std::string;
  }
  route_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EntitySelector::mutable_route_id() {
  set_has_route_id();
  if (route_id_ == &::google::protobuf::internal::kEmptyString) {
    route_id_ = new ::std::string;
  }
  return route_id_;
}
inline ::std::string* EntitySelector::release_route_id() {
  clear_has_route_id();
  if (route_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = route_id_;
    route_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EntitySelector::set_allocated_route_id(::std::string* route_id) {
  if (route_id_ != &::google::protobuf::internal::kEmptyString) {
    delete route_id_;
  }
  if (route_id) {
    set_has_route_id();
    route_id_ = route_id;
  } else {
    clear_has_route_id();
    route_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 route_type = 3;
inline bool EntitySelector::has_route_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EntitySelector::set_has_route_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EntitySelector::clear_has_route_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EntitySelector::clear_route_type() {
  route_type_ = 0;
  clear_has_route_type();
}
inline ::google::protobuf::int32 EntitySelector::route_type() const {
  return route_type_;
}
inline void EntitySelector::set_route_type(::google::protobuf::int32 value) {
  set_has_route_type();
  route_type_ = value;
}

// optional .transit_realtime.TripDescriptor trip = 4;
inline bool EntitySelector::has_trip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EntitySelector::set_has_trip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EntitySelector::clear_has_trip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EntitySelector::clear_trip() {
  if (trip_ != NULL) trip_->::transit_realtime::TripDescriptor::Clear();
  clear_has_trip();
}
inline const ::transit_realtime::TripDescriptor& EntitySelector::trip() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return trip_ != NULL ? *trip_ : *default_instance().trip_;
#else
  return trip_ != NULL ? *trip_ : *default_instance_->trip_;
#endif
}
inline ::transit_realtime::TripDescriptor* EntitySelector::mutable_trip() {
  set_has_trip();
  if (trip_ == NULL) trip_ = new ::transit_realtime::TripDescriptor;
  return trip_;
}
inline ::transit_realtime::TripDescriptor* EntitySelector::release_trip() {
  clear_has_trip();
  ::transit_realtime::TripDescriptor* temp = trip_;
  trip_ = NULL;
  return temp;
}
inline void EntitySelector::set_allocated_trip(::transit_realtime::TripDescriptor* trip) {
  delete trip_;
  trip_ = trip;
  if (trip) {
    set_has_trip();
  } else {
    clear_has_trip();
  }
}

// optional string stop_id = 5;
inline bool EntitySelector::has_stop_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EntitySelector::set_has_stop_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EntitySelector::clear_has_stop_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EntitySelector::clear_stop_id() {
  if (stop_id_ != &::google::protobuf::internal::kEmptyString) {
    stop_id_->clear();
  }
  clear_has_stop_id();
}
inline const ::std::string& EntitySelector::stop_id() const {
  return *stop_id_;
}
inline void EntitySelector::set_stop_id(const ::std::string& value) {
  set_has_stop_id();
  if (stop_id_ == &::google::protobuf::internal::kEmptyString) {
    stop_id_ = new ::std::string;
  }
  stop_id_->assign(value);
}
inline void EntitySelector::set_stop_id(const char* value) {
  set_has_stop_id();
  if (stop_id_ == &::google::protobuf::internal::kEmptyString) {
    stop_id_ = new ::std::string;
  }
  stop_id_->assign(value);
}
inline void EntitySelector::set_stop_id(const char* value, size_t size) {
  set_has_stop_id();
  if (stop_id_ == &::google::protobuf::internal::kEmptyString) {
    stop_id_ = new ::std::string;
  }
  stop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EntitySelector::mutable_stop_id() {
  set_has_stop_id();
  if (stop_id_ == &::google::protobuf::internal::kEmptyString) {
    stop_id_ = new ::std::string;
  }
  return stop_id_;
}
inline ::std::string* EntitySelector::release_stop_id() {
  clear_has_stop_id();
  if (stop_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stop_id_;
    stop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EntitySelector::set_allocated_stop_id(::std::string* stop_id) {
  if (stop_id_ != &::google::protobuf::internal::kEmptyString) {
    delete stop_id_;
  }
  if (stop_id) {
    set_has_stop_id();
    stop_id_ = stop_id;
  } else {
    clear_has_stop_id();
    stop_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TranslatedString_Translation

// required string text = 1;
inline bool TranslatedString_Translation::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TranslatedString_Translation::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TranslatedString_Translation::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TranslatedString_Translation::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& TranslatedString_Translation::text() const {
  return *text_;
}
inline void TranslatedString_Translation::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TranslatedString_Translation::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TranslatedString_Translation::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TranslatedString_Translation::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* TranslatedString_Translation::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TranslatedString_Translation::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string language = 2;
inline bool TranslatedString_Translation::has_language() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TranslatedString_Translation::set_has_language() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TranslatedString_Translation::clear_has_language() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TranslatedString_Translation::clear_language() {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    language_->clear();
  }
  clear_has_language();
}
inline const ::std::string& TranslatedString_Translation::language() const {
  return *language_;
}
inline void TranslatedString_Translation::set_language(const ::std::string& value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void TranslatedString_Translation::set_language(const char* value) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void TranslatedString_Translation::set_language(const char* value, size_t size) {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TranslatedString_Translation::mutable_language() {
  set_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    language_ = new ::std::string;
  }
  return language_;
}
inline ::std::string* TranslatedString_Translation::release_language() {
  clear_has_language();
  if (language_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = language_;
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TranslatedString_Translation::set_allocated_language(::std::string* language) {
  if (language_ != &::google::protobuf::internal::kEmptyString) {
    delete language_;
  }
  if (language) {
    set_has_language();
    language_ = language;
  } else {
    clear_has_language();
    language_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TranslatedString

// repeated .transit_realtime.TranslatedString.Translation translation = 1;
inline int TranslatedString::translation_size() const {
  return translation_.size();
}
inline void TranslatedString::clear_translation() {
  translation_.Clear();
}
inline const ::transit_realtime::TranslatedString_Translation& TranslatedString::translation(int index) const {
  return translation_.Get(index);
}
inline ::transit_realtime::TranslatedString_Translation* TranslatedString::mutable_translation(int index) {
  return translation_.Mutable(index);
}
inline ::transit_realtime::TranslatedString_Translation* TranslatedString::add_translation() {
  return translation_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >&
TranslatedString::translation() const {
  return translation_;
}
inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >*
TranslatedString::mutable_translation() {
  return &translation_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace transit_realtime

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gtfs_2drealtime_2eproto__INCLUDED
